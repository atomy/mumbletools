// **********************************************************************
//
// Copyright (c) 2003-2011 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.4.2
//
// <auto-generated>
//
// Generated from file `ServerPrxHelper.java'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

package Murmur;

/**
 * Per-server interface. This includes all methods for configuring and altering
 * the state of a single virtual server. You can retrieve a pointer to this interface
 * from one of the methods in {@link Meta}.
 **/
public final class ServerPrxHelper extends Ice.ObjectPrxHelperBase implements ServerPrx
{
    /**
     * Add a callback. The callback will receive notifications about changes to users and channels.
     * 
     * @param cb Callback interface which will receive notifications.
     * @see removeCallback
     **/
    public void
    addCallback(ServerCallbackPrx cb)
        throws InvalidCallbackException,
               InvalidSecretException,
               ServerBootedException
    {
        addCallback(cb, null, false);
    }

    /**
     * Add a callback. The callback will receive notifications about changes to users and channels.
     * 
     * @param cb Callback interface which will receive notifications.
     * @see removeCallback
     * @param __ctx The Context map to send with the invocation.
     **/
    public void
    addCallback(ServerCallbackPrx cb, java.util.Map<String, String> __ctx)
        throws InvalidCallbackException,
               InvalidSecretException,
               ServerBootedException
    {
        addCallback(cb, __ctx, true);
    }

    private void
    addCallback(ServerCallbackPrx cb, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidCallbackException,
               InvalidSecretException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("addCallback");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                __del.addCallback(cb, __ctx);
                return;
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __handleExceptionWrapper(__delBase, __ex);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __addCallback_name = "addCallback";

    /**
     * Add a callback. The callback will receive notifications about changes to users and channels.
     * 
     * @param __cb The callback object for the operation.
     * @param cb Callback interface which will receive notifications.
     **/
    public Ice.AsyncResult begin_addCallback(ServerCallbackPrx cb)
    {
        return begin_addCallback(cb, null, false, null);
    }

    /**
     * Add a callback. The callback will receive notifications about changes to users and channels.
     * 
     * @param __cb The callback object for the operation.
     * @param cb Callback interface which will receive notifications.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_addCallback(ServerCallbackPrx cb, java.util.Map<String, String> __ctx)
    {
        return begin_addCallback(cb, __ctx, true, null);
    }

    /**
     * Add a callback. The callback will receive notifications about changes to users and channels.
     * 
     * @param __cb The callback object for the operation.
     * @param cb Callback interface which will receive notifications.
     **/
    public Ice.AsyncResult begin_addCallback(ServerCallbackPrx cb, Ice.Callback __cb)
    {
        return begin_addCallback(cb, null, false, __cb);
    }

    /**
     * Add a callback. The callback will receive notifications about changes to users and channels.
     * 
     * @param __cb The callback object for the operation.
     * @param cb Callback interface which will receive notifications.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_addCallback(ServerCallbackPrx cb, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_addCallback(cb, __ctx, true, __cb);
    }

    /**
     * Add a callback. The callback will receive notifications about changes to users and channels.
     * 
     * @param __cb The callback object for the operation.
     * @param cb Callback interface which will receive notifications.
     **/
    public Ice.AsyncResult begin_addCallback(ServerCallbackPrx cb, Callback_Server_addCallback __cb)
    {
        return begin_addCallback(cb, null, false, __cb);
    }

    /**
     * Add a callback. The callback will receive notifications about changes to users and channels.
     * 
     * @param __cb The callback object for the operation.
     * @param cb Callback interface which will receive notifications.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_addCallback(ServerCallbackPrx cb, java.util.Map<String, String> __ctx, Callback_Server_addCallback __cb)
    {
        return begin_addCallback(cb, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_addCallback(ServerCallbackPrx cb, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__addCallback_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __addCallback_name, __cb);
        try
        {
            __result.__prepare(__addCallback_name, Ice.OperationMode.Normal, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            ServerCallbackPrxHelper.__write(__os, cb);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     **/
    public void end_addCallback(Ice.AsyncResult __result)
        throws InvalidCallbackException,
               InvalidSecretException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __addCallback_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidCallbackException __ex)
            {
                throw __ex;
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        IceInternal.BasicStream __is = __result.__is();
        __is.skipEmptyEncaps();
    }

    /**
     * Add a new channel.
     * @param name Name of new channel.
     * @param parent Channel ID of parent channel. See {@link Channel.id}.
     * @return ID of newly created channel.
     **/
    public int
    addChannel(String name, int parent)
        throws InvalidChannelException,
               InvalidSecretException,
               ServerBootedException
    {
        return addChannel(name, parent, null, false);
    }

    /**
     * Add a new channel.
     * @param name Name of new channel.
     * @param parent Channel ID of parent channel. See {@link Channel.id}.
     * @param __ctx The Context map to send with the invocation.
     * @return ID of newly created channel.
     **/
    public int
    addChannel(String name, int parent, java.util.Map<String, String> __ctx)
        throws InvalidChannelException,
               InvalidSecretException,
               ServerBootedException
    {
        return addChannel(name, parent, __ctx, true);
    }

    private int
    addChannel(String name, int parent, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidChannelException,
               InvalidSecretException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("addChannel");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                return __del.addChannel(name, parent, __ctx);
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __handleExceptionWrapper(__delBase, __ex);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __addChannel_name = "addChannel";

    /**
     * Add a new channel.
     * @param __cb The callback object for the operation.
     * @param name Name of new channel.
     **/
    public Ice.AsyncResult begin_addChannel(String name, int parent)
    {
        return begin_addChannel(name, parent, null, false, null);
    }

    /**
     * Add a new channel.
     * @param __cb The callback object for the operation.
     * @param name Name of new channel.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_addChannel(String name, int parent, java.util.Map<String, String> __ctx)
    {
        return begin_addChannel(name, parent, __ctx, true, null);
    }

    /**
     * Add a new channel.
     * @param __cb The callback object for the operation.
     * @param name Name of new channel.
     **/
    public Ice.AsyncResult begin_addChannel(String name, int parent, Ice.Callback __cb)
    {
        return begin_addChannel(name, parent, null, false, __cb);
    }

    /**
     * Add a new channel.
     * @param __cb The callback object for the operation.
     * @param name Name of new channel.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_addChannel(String name, int parent, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_addChannel(name, parent, __ctx, true, __cb);
    }

    /**
     * Add a new channel.
     * @param __cb The callback object for the operation.
     * @param name Name of new channel.
     **/
    public Ice.AsyncResult begin_addChannel(String name, int parent, Callback_Server_addChannel __cb)
    {
        return begin_addChannel(name, parent, null, false, __cb);
    }

    /**
     * Add a new channel.
     * @param __cb The callback object for the operation.
     * @param name Name of new channel.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_addChannel(String name, int parent, java.util.Map<String, String> __ctx, Callback_Server_addChannel __cb)
    {
        return begin_addChannel(name, parent, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_addChannel(String name, int parent, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__addChannel_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __addChannel_name, __cb);
        try
        {
            __result.__prepare(__addChannel_name, Ice.OperationMode.Normal, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.writeString(name);
            __os.writeInt(parent);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param __ret (return value) ID of newly created channel.
     **/
    public int end_addChannel(Ice.AsyncResult __result)
        throws InvalidChannelException,
               InvalidSecretException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __addChannel_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidChannelException __ex)
            {
                throw __ex;
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        int __ret;
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        __ret = __is.readInt();
        __is.endReadEncaps();
        return __ret;
    }

    /**
     * Add a context callback. This is done per user, and will add a context menu action for the user.
     * 
     * @param session Session of user which should receive context entry.
     * @param action Action string, a unique name to associate with the action.
     * @param text Name of action shown to user.
     * @param cb Callback interface which will receive notifications.
     * @param ctx Context this should be used in. Needs to be one or a combination of {@link ContextServer}, {@link ContextChannel} and {@link ContextUser}.
     * @see removeContextCallback
     **/
    public void
    addContextCallback(int session, String action, String text, ServerContextCallbackPrx cb, int ctx)
        throws InvalidCallbackException,
               InvalidSecretException,
               ServerBootedException
    {
        addContextCallback(session, action, text, cb, ctx, null, false);
    }

    /**
     * Add a context callback. This is done per user, and will add a context menu action for the user.
     * 
     * @param session Session of user which should receive context entry.
     * @param action Action string, a unique name to associate with the action.
     * @param text Name of action shown to user.
     * @param cb Callback interface which will receive notifications.
     * @param ctx Context this should be used in. Needs to be one or a combination of {@link ContextServer}, {@link ContextChannel} and {@link ContextUser}.
     * @see removeContextCallback
     * @param __ctx The Context map to send with the invocation.
     **/
    public void
    addContextCallback(int session, String action, String text, ServerContextCallbackPrx cb, int ctx, java.util.Map<String, String> __ctx)
        throws InvalidCallbackException,
               InvalidSecretException,
               ServerBootedException
    {
        addContextCallback(session, action, text, cb, ctx, __ctx, true);
    }

    private void
    addContextCallback(int session, String action, String text, ServerContextCallbackPrx cb, int ctx, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidCallbackException,
               InvalidSecretException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("addContextCallback");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                __del.addContextCallback(session, action, text, cb, ctx, __ctx);
                return;
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __handleExceptionWrapper(__delBase, __ex);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __addContextCallback_name = "addContextCallback";

    /**
     * Add a context callback. This is done per user, and will add a context menu action for the user.
     * 
     * @param __cb The callback object for the operation.
     * @param session Session of user which should receive context entry.
     * @param text Name of action shown to user.
     * @param ctx Context this should be used in. Needs to be one or a combination of {@link ContextServer}, {@link ContextChannel} and {@link ContextUser}.
     **/
    public Ice.AsyncResult begin_addContextCallback(int session, String action, String text, ServerContextCallbackPrx cb, int ctx)
    {
        return begin_addContextCallback(session, action, text, cb, ctx, null, false, null);
    }

    /**
     * Add a context callback. This is done per user, and will add a context menu action for the user.
     * 
     * @param __cb The callback object for the operation.
     * @param session Session of user which should receive context entry.
     * @param text Name of action shown to user.
     * @param ctx Context this should be used in. Needs to be one or a combination of {@link ContextServer}, {@link ContextChannel} and {@link ContextUser}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_addContextCallback(int session, String action, String text, ServerContextCallbackPrx cb, int ctx, java.util.Map<String, String> __ctx)
    {
        return begin_addContextCallback(session, action, text, cb, ctx, __ctx, true, null);
    }

    /**
     * Add a context callback. This is done per user, and will add a context menu action for the user.
     * 
     * @param __cb The callback object for the operation.
     * @param session Session of user which should receive context entry.
     * @param text Name of action shown to user.
     * @param ctx Context this should be used in. Needs to be one or a combination of {@link ContextServer}, {@link ContextChannel} and {@link ContextUser}.
     **/
    public Ice.AsyncResult begin_addContextCallback(int session, String action, String text, ServerContextCallbackPrx cb, int ctx, Ice.Callback __cb)
    {
        return begin_addContextCallback(session, action, text, cb, ctx, null, false, __cb);
    }

    /**
     * Add a context callback. This is done per user, and will add a context menu action for the user.
     * 
     * @param __cb The callback object for the operation.
     * @param session Session of user which should receive context entry.
     * @param text Name of action shown to user.
     * @param ctx Context this should be used in. Needs to be one or a combination of {@link ContextServer}, {@link ContextChannel} and {@link ContextUser}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_addContextCallback(int session, String action, String text, ServerContextCallbackPrx cb, int ctx, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_addContextCallback(session, action, text, cb, ctx, __ctx, true, __cb);
    }

    /**
     * Add a context callback. This is done per user, and will add a context menu action for the user.
     * 
     * @param __cb The callback object for the operation.
     * @param session Session of user which should receive context entry.
     * @param text Name of action shown to user.
     * @param ctx Context this should be used in. Needs to be one or a combination of {@link ContextServer}, {@link ContextChannel} and {@link ContextUser}.
     **/
    public Ice.AsyncResult begin_addContextCallback(int session, String action, String text, ServerContextCallbackPrx cb, int ctx, Callback_Server_addContextCallback __cb)
    {
        return begin_addContextCallback(session, action, text, cb, ctx, null, false, __cb);
    }

    /**
     * Add a context callback. This is done per user, and will add a context menu action for the user.
     * 
     * @param __cb The callback object for the operation.
     * @param session Session of user which should receive context entry.
     * @param text Name of action shown to user.
     * @param ctx Context this should be used in. Needs to be one or a combination of {@link ContextServer}, {@link ContextChannel} and {@link ContextUser}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_addContextCallback(int session, String action, String text, ServerContextCallbackPrx cb, int ctx, java.util.Map<String, String> __ctx, Callback_Server_addContextCallback __cb)
    {
        return begin_addContextCallback(session, action, text, cb, ctx, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_addContextCallback(int session, String action, String text, ServerContextCallbackPrx cb, int ctx, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__addContextCallback_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __addContextCallback_name, __cb);
        try
        {
            __result.__prepare(__addContextCallback_name, Ice.OperationMode.Normal, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.writeInt(session);
            __os.writeString(action);
            __os.writeString(text);
            ServerContextCallbackPrxHelper.__write(__os, cb);
            __os.writeInt(ctx);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     **/
    public void end_addContextCallback(Ice.AsyncResult __result)
        throws InvalidCallbackException,
               InvalidSecretException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __addContextCallback_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidCallbackException __ex)
            {
                throw __ex;
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        IceInternal.BasicStream __is = __result.__is();
        __is.skipEmptyEncaps();
    }

    /**
     * Temporarily add a user to a group on a channel. This state is not saved, and is intended for temporary memberships.
     * @param channelid Channel ID of channel to add to. See {@link Channel.id}.
     * @param session Connection ID of user. See {@link User.session}.
     * @param group Group name to add to.
     **/
    public void
    addUserToGroup(int channelid, int session, String group)
        throws InvalidChannelException,
               InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        addUserToGroup(channelid, session, group, null, false);
    }

    /**
     * Temporarily add a user to a group on a channel. This state is not saved, and is intended for temporary memberships.
     * @param channelid Channel ID of channel to add to. See {@link Channel.id}.
     * @param session Connection ID of user. See {@link User.session}.
     * @param group Group name to add to.
     * @param __ctx The Context map to send with the invocation.
     **/
    public void
    addUserToGroup(int channelid, int session, String group, java.util.Map<String, String> __ctx)
        throws InvalidChannelException,
               InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        addUserToGroup(channelid, session, group, __ctx, true);
    }

    private void
    addUserToGroup(int channelid, int session, String group, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidChannelException,
               InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("addUserToGroup");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                __del.addUserToGroup(channelid, session, group, __ctx);
                return;
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __addUserToGroup_name = "addUserToGroup";

    /**
     * Temporarily add a user to a group on a channel. This state is not saved, and is intended for temporary memberships.
     * @param __cb The callback object for the operation.
     * @param channelid Channel ID of channel to add to. See {@link Channel.id}.
     * @param group Group name to add to.
     **/
    public Ice.AsyncResult begin_addUserToGroup(int channelid, int session, String group)
    {
        return begin_addUserToGroup(channelid, session, group, null, false, null);
    }

    /**
     * Temporarily add a user to a group on a channel. This state is not saved, and is intended for temporary memberships.
     * @param __cb The callback object for the operation.
     * @param channelid Channel ID of channel to add to. See {@link Channel.id}.
     * @param group Group name to add to.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_addUserToGroup(int channelid, int session, String group, java.util.Map<String, String> __ctx)
    {
        return begin_addUserToGroup(channelid, session, group, __ctx, true, null);
    }

    /**
     * Temporarily add a user to a group on a channel. This state is not saved, and is intended for temporary memberships.
     * @param __cb The callback object for the operation.
     * @param channelid Channel ID of channel to add to. See {@link Channel.id}.
     * @param group Group name to add to.
     **/
    public Ice.AsyncResult begin_addUserToGroup(int channelid, int session, String group, Ice.Callback __cb)
    {
        return begin_addUserToGroup(channelid, session, group, null, false, __cb);
    }

    /**
     * Temporarily add a user to a group on a channel. This state is not saved, and is intended for temporary memberships.
     * @param __cb The callback object for the operation.
     * @param channelid Channel ID of channel to add to. See {@link Channel.id}.
     * @param group Group name to add to.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_addUserToGroup(int channelid, int session, String group, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_addUserToGroup(channelid, session, group, __ctx, true, __cb);
    }

    /**
     * Temporarily add a user to a group on a channel. This state is not saved, and is intended for temporary memberships.
     * @param __cb The callback object for the operation.
     * @param channelid Channel ID of channel to add to. See {@link Channel.id}.
     * @param group Group name to add to.
     **/
    public Ice.AsyncResult begin_addUserToGroup(int channelid, int session, String group, Callback_Server_addUserToGroup __cb)
    {
        return begin_addUserToGroup(channelid, session, group, null, false, __cb);
    }

    /**
     * Temporarily add a user to a group on a channel. This state is not saved, and is intended for temporary memberships.
     * @param __cb The callback object for the operation.
     * @param channelid Channel ID of channel to add to. See {@link Channel.id}.
     * @param group Group name to add to.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_addUserToGroup(int channelid, int session, String group, java.util.Map<String, String> __ctx, Callback_Server_addUserToGroup __cb)
    {
        return begin_addUserToGroup(channelid, session, group, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_addUserToGroup(int channelid, int session, String group, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__addUserToGroup_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __addUserToGroup_name, __cb);
        try
        {
            __result.__prepare(__addUserToGroup_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.writeInt(channelid);
            __os.writeInt(session);
            __os.writeString(group);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     **/
    public void end_addUserToGroup(Ice.AsyncResult __result)
        throws InvalidChannelException,
               InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __addUserToGroup_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidChannelException __ex)
            {
                throw __ex;
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(InvalidSessionException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        IceInternal.BasicStream __is = __result.__is();
        __is.skipEmptyEncaps();
    }

    /**
     * Delete server and all it's configuration.
     **/
    public void
    delete()
        throws InvalidSecretException,
               ServerBootedException
    {
        delete(null, false);
    }

    /**
     * Delete server and all it's configuration.
     * @param __ctx The Context map to send with the invocation.
     **/
    public void
    delete(java.util.Map<String, String> __ctx)
        throws InvalidSecretException,
               ServerBootedException
    {
        delete(__ctx, true);
    }

    private void
    delete(java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("delete");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                __del.delete(__ctx);
                return;
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __handleExceptionWrapper(__delBase, __ex);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __delete_name = "delete";

    /**
     * Delete server and all it's configuration.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_delete()
    {
        return begin_delete(null, false, null);
    }

    /**
     * Delete server and all it's configuration.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_delete(java.util.Map<String, String> __ctx)
    {
        return begin_delete(__ctx, true, null);
    }

    /**
     * Delete server and all it's configuration.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_delete(Ice.Callback __cb)
    {
        return begin_delete(null, false, __cb);
    }

    /**
     * Delete server and all it's configuration.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_delete(java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_delete(__ctx, true, __cb);
    }

    /**
     * Delete server and all it's configuration.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_delete(Callback_Server_delete __cb)
    {
        return begin_delete(null, false, __cb);
    }

    /**
     * Delete server and all it's configuration.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_delete(java.util.Map<String, String> __ctx, Callback_Server_delete __cb)
    {
        return begin_delete(__ctx, true, __cb);
    }

    private Ice.AsyncResult begin_delete(java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__delete_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __delete_name, __cb);
        try
        {
            __result.__prepare(__delete_name, Ice.OperationMode.Normal, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     **/
    public void end_delete(Ice.AsyncResult __result)
        throws InvalidSecretException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __delete_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        IceInternal.BasicStream __is = __result.__is();
        __is.skipEmptyEncaps();
    }

    /**
     * Retrieve ACLs and Groups on a channel.
     * @param channelid Channel ID of channel to fetch from. See {@link Channel.id}.
     * @param acls List of ACLs on the channel. This will include inherited ACLs.
     * @param groups List of groups on the channel. This will include inherited groups.
     * @param inherit Does this channel inherit ACLs from the parent channel?
     **/
    public void
    getACL(int channelid, ACLListHolder acls, GroupListHolder groups, Ice.BooleanHolder inherit)
        throws InvalidChannelException,
               InvalidSecretException,
               ServerBootedException
    {
        getACL(channelid, acls, groups, inherit, null, false);
    }

    /**
     * Retrieve ACLs and Groups on a channel.
     * @param channelid Channel ID of channel to fetch from. See {@link Channel.id}.
     * @param acls List of ACLs on the channel. This will include inherited ACLs.
     * @param groups List of groups on the channel. This will include inherited groups.
     * @param inherit Does this channel inherit ACLs from the parent channel?
     * @param __ctx The Context map to send with the invocation.
     **/
    public void
    getACL(int channelid, ACLListHolder acls, GroupListHolder groups, Ice.BooleanHolder inherit, java.util.Map<String, String> __ctx)
        throws InvalidChannelException,
               InvalidSecretException,
               ServerBootedException
    {
        getACL(channelid, acls, groups, inherit, __ctx, true);
    }

    private void
    getACL(int channelid, ACLListHolder acls, GroupListHolder groups, Ice.BooleanHolder inherit, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidChannelException,
               InvalidSecretException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("getACL");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                __del.getACL(channelid, acls, groups, inherit, __ctx);
                return;
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __getACL_name = "getACL";

    /**
     * Retrieve ACLs and Groups on a channel.
     * @param __cb The callback object for the operation.
     * @param channelid Channel ID of channel to fetch from. See {@link Channel.id}.
     **/
    public Ice.AsyncResult begin_getACL(int channelid)
    {
        return begin_getACL(channelid, null, false, null);
    }

    /**
     * Retrieve ACLs and Groups on a channel.
     * @param __cb The callback object for the operation.
     * @param channelid Channel ID of channel to fetch from. See {@link Channel.id}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getACL(int channelid, java.util.Map<String, String> __ctx)
    {
        return begin_getACL(channelid, __ctx, true, null);
    }

    /**
     * Retrieve ACLs and Groups on a channel.
     * @param __cb The callback object for the operation.
     * @param channelid Channel ID of channel to fetch from. See {@link Channel.id}.
     **/
    public Ice.AsyncResult begin_getACL(int channelid, Ice.Callback __cb)
    {
        return begin_getACL(channelid, null, false, __cb);
    }

    /**
     * Retrieve ACLs and Groups on a channel.
     * @param __cb The callback object for the operation.
     * @param channelid Channel ID of channel to fetch from. See {@link Channel.id}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getACL(int channelid, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_getACL(channelid, __ctx, true, __cb);
    }

    /**
     * Retrieve ACLs and Groups on a channel.
     * @param __cb The callback object for the operation.
     * @param channelid Channel ID of channel to fetch from. See {@link Channel.id}.
     **/
    public Ice.AsyncResult begin_getACL(int channelid, Callback_Server_getACL __cb)
    {
        return begin_getACL(channelid, null, false, __cb);
    }

    /**
     * Retrieve ACLs and Groups on a channel.
     * @param __cb The callback object for the operation.
     * @param channelid Channel ID of channel to fetch from. See {@link Channel.id}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getACL(int channelid, java.util.Map<String, String> __ctx, Callback_Server_getACL __cb)
    {
        return begin_getACL(channelid, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_getACL(int channelid, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__getACL_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __getACL_name, __cb);
        try
        {
            __result.__prepare(__getACL_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.writeInt(channelid);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param acls List of ACLs on the channel. This will include inherited ACLs.
     * @param inherit Does this channel inherit ACLs from the parent channel?
     **/
    public void end_getACL(ACLListHolder acls, GroupListHolder groups, Ice.BooleanHolder inherit, Ice.AsyncResult __result)
        throws InvalidChannelException,
               InvalidSecretException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __getACL_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidChannelException __ex)
            {
                throw __ex;
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        acls.value = ACLListHelper.read(__is);
        groups.value = GroupListHelper.read(__is);
        inherit.value = __is.readBool();
        __is.endReadEncaps();
    }

    /**
     * Retrieve all configuration items.
     * @return All configured values. If a value isn't set here, the value from {@link Meta.getDefaultConf} is used.
     **/
    public java.util.Map<java.lang.String, java.lang.String>
    getAllConf()
        throws InvalidSecretException
    {
        return getAllConf(null, false);
    }

    /**
     * Retrieve all configuration items.
     * @param __ctx The Context map to send with the invocation.
     * @return All configured values. If a value isn't set here, the value from {@link Meta.getDefaultConf} is used.
     **/
    public java.util.Map<java.lang.String, java.lang.String>
    getAllConf(java.util.Map<String, String> __ctx)
        throws InvalidSecretException
    {
        return getAllConf(__ctx, true);
    }

    private java.util.Map<java.lang.String, java.lang.String>
    getAllConf(java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("getAllConf");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                return __del.getAllConf(__ctx);
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __getAllConf_name = "getAllConf";

    /**
     * Retrieve all configuration items.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getAllConf()
    {
        return begin_getAllConf(null, false, null);
    }

    /**
     * Retrieve all configuration items.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getAllConf(java.util.Map<String, String> __ctx)
    {
        return begin_getAllConf(__ctx, true, null);
    }

    /**
     * Retrieve all configuration items.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getAllConf(Ice.Callback __cb)
    {
        return begin_getAllConf(null, false, __cb);
    }

    /**
     * Retrieve all configuration items.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getAllConf(java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_getAllConf(__ctx, true, __cb);
    }

    /**
     * Retrieve all configuration items.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getAllConf(Callback_Server_getAllConf __cb)
    {
        return begin_getAllConf(null, false, __cb);
    }

    /**
     * Retrieve all configuration items.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getAllConf(java.util.Map<String, String> __ctx, Callback_Server_getAllConf __cb)
    {
        return begin_getAllConf(__ctx, true, __cb);
    }

    private Ice.AsyncResult begin_getAllConf(java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__getAllConf_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __getAllConf_name, __cb);
        try
        {
            __result.__prepare(__getAllConf_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param __ret (return value) All configured values. If a value isn't set here, the value from {@link Meta.getDefaultConf} is used.
     **/
    public java.util.Map<java.lang.String, java.lang.String> end_getAllConf(Ice.AsyncResult __result)
        throws InvalidSecretException
    {
        Ice.AsyncResult.__check(__result, this, __getAllConf_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        java.util.Map<java.lang.String, java.lang.String> __ret;
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        __ret = ConfigMapHelper.read(__is);
        __is.endReadEncaps();
        return __ret;
    }

    /**
     * Fetch all current IP bans on the server.
     * @return List of bans.
     **/
    public Ban[]
    getBans()
        throws InvalidSecretException,
               ServerBootedException
    {
        return getBans(null, false);
    }

    /**
     * Fetch all current IP bans on the server.
     * @param __ctx The Context map to send with the invocation.
     * @return List of bans.
     **/
    public Ban[]
    getBans(java.util.Map<String, String> __ctx)
        throws InvalidSecretException,
               ServerBootedException
    {
        return getBans(__ctx, true);
    }

    private Ban[]
    getBans(java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("getBans");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                return __del.getBans(__ctx);
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __getBans_name = "getBans";

    /**
     * Fetch all current IP bans on the server.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getBans()
    {
        return begin_getBans(null, false, null);
    }

    /**
     * Fetch all current IP bans on the server.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getBans(java.util.Map<String, String> __ctx)
    {
        return begin_getBans(__ctx, true, null);
    }

    /**
     * Fetch all current IP bans on the server.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getBans(Ice.Callback __cb)
    {
        return begin_getBans(null, false, __cb);
    }

    /**
     * Fetch all current IP bans on the server.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getBans(java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_getBans(__ctx, true, __cb);
    }

    /**
     * Fetch all current IP bans on the server.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getBans(Callback_Server_getBans __cb)
    {
        return begin_getBans(null, false, __cb);
    }

    /**
     * Fetch all current IP bans on the server.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getBans(java.util.Map<String, String> __ctx, Callback_Server_getBans __cb)
    {
        return begin_getBans(__ctx, true, __cb);
    }

    private Ice.AsyncResult begin_getBans(java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__getBans_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __getBans_name, __cb);
        try
        {
            __result.__prepare(__getBans_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param __ret (return value) List of bans.
     **/
    public Ban[] end_getBans(Ice.AsyncResult __result)
        throws InvalidSecretException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __getBans_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        Ban[] __ret;
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        __ret = BanListHelper.read(__is);
        __is.endReadEncaps();
        return __ret;
    }

    /**
     * Fetch certificate of user. This returns the complete certificate chain of a user.
     * @param session Connection ID of user. See {@link User.session}.
     * @return Certificate list of user.
     **/
    public byte[][]
    getCertificateList(int session)
        throws InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        return getCertificateList(session, null, false);
    }

    /**
     * Fetch certificate of user. This returns the complete certificate chain of a user.
     * @param session Connection ID of user. See {@link User.session}.
     * @param __ctx The Context map to send with the invocation.
     * @return Certificate list of user.
     **/
    public byte[][]
    getCertificateList(int session, java.util.Map<String, String> __ctx)
        throws InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        return getCertificateList(session, __ctx, true);
    }

    private byte[][]
    getCertificateList(int session, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("getCertificateList");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                return __del.getCertificateList(session, __ctx);
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __getCertificateList_name = "getCertificateList";

    /**
     * Fetch certificate of user. This returns the complete certificate chain of a user.
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     **/
    public Ice.AsyncResult begin_getCertificateList(int session)
    {
        return begin_getCertificateList(session, null, false, null);
    }

    /**
     * Fetch certificate of user. This returns the complete certificate chain of a user.
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getCertificateList(int session, java.util.Map<String, String> __ctx)
    {
        return begin_getCertificateList(session, __ctx, true, null);
    }

    /**
     * Fetch certificate of user. This returns the complete certificate chain of a user.
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     **/
    public Ice.AsyncResult begin_getCertificateList(int session, Ice.Callback __cb)
    {
        return begin_getCertificateList(session, null, false, __cb);
    }

    /**
     * Fetch certificate of user. This returns the complete certificate chain of a user.
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getCertificateList(int session, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_getCertificateList(session, __ctx, true, __cb);
    }

    /**
     * Fetch certificate of user. This returns the complete certificate chain of a user.
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     **/
    public Ice.AsyncResult begin_getCertificateList(int session, Callback_Server_getCertificateList __cb)
    {
        return begin_getCertificateList(session, null, false, __cb);
    }

    /**
     * Fetch certificate of user. This returns the complete certificate chain of a user.
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getCertificateList(int session, java.util.Map<String, String> __ctx, Callback_Server_getCertificateList __cb)
    {
        return begin_getCertificateList(session, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_getCertificateList(int session, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__getCertificateList_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __getCertificateList_name, __cb);
        try
        {
            __result.__prepare(__getCertificateList_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.writeInt(session);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param __ret (return value) Certificate list of user.
     **/
    public byte[][] end_getCertificateList(Ice.AsyncResult __result)
        throws InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __getCertificateList_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(InvalidSessionException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        byte[][] __ret;
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        __ret = CertificateListHelper.read(__is);
        __is.endReadEncaps();
        return __ret;
    }

    /**
     * Get state of single channel.
     * @param channelid ID of Channel. See {@link Channel.id}.
     * @return State of channel.
     * @see setChannelState
     * @see getChannels
     **/
    public Channel
    getChannelState(int channelid)
        throws InvalidChannelException,
               InvalidSecretException,
               ServerBootedException
    {
        return getChannelState(channelid, null, false);
    }

    /**
     * Get state of single channel.
     * @param channelid ID of Channel. See {@link Channel.id}.
     * @param __ctx The Context map to send with the invocation.
     * @return State of channel.
     * @see setChannelState
     * @see getChannels
     **/
    public Channel
    getChannelState(int channelid, java.util.Map<String, String> __ctx)
        throws InvalidChannelException,
               InvalidSecretException,
               ServerBootedException
    {
        return getChannelState(channelid, __ctx, true);
    }

    private Channel
    getChannelState(int channelid, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidChannelException,
               InvalidSecretException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("getChannelState");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                return __del.getChannelState(channelid, __ctx);
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __getChannelState_name = "getChannelState";

    /**
     * Get state of single channel.
     * @param __cb The callback object for the operation.
     * @param channelid ID of Channel. See {@link Channel.id}.
     **/
    public Ice.AsyncResult begin_getChannelState(int channelid)
    {
        return begin_getChannelState(channelid, null, false, null);
    }

    /**
     * Get state of single channel.
     * @param __cb The callback object for the operation.
     * @param channelid ID of Channel. See {@link Channel.id}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getChannelState(int channelid, java.util.Map<String, String> __ctx)
    {
        return begin_getChannelState(channelid, __ctx, true, null);
    }

    /**
     * Get state of single channel.
     * @param __cb The callback object for the operation.
     * @param channelid ID of Channel. See {@link Channel.id}.
     **/
    public Ice.AsyncResult begin_getChannelState(int channelid, Ice.Callback __cb)
    {
        return begin_getChannelState(channelid, null, false, __cb);
    }

    /**
     * Get state of single channel.
     * @param __cb The callback object for the operation.
     * @param channelid ID of Channel. See {@link Channel.id}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getChannelState(int channelid, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_getChannelState(channelid, __ctx, true, __cb);
    }

    /**
     * Get state of single channel.
     * @param __cb The callback object for the operation.
     * @param channelid ID of Channel. See {@link Channel.id}.
     **/
    public Ice.AsyncResult begin_getChannelState(int channelid, Callback_Server_getChannelState __cb)
    {
        return begin_getChannelState(channelid, null, false, __cb);
    }

    /**
     * Get state of single channel.
     * @param __cb The callback object for the operation.
     * @param channelid ID of Channel. See {@link Channel.id}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getChannelState(int channelid, java.util.Map<String, String> __ctx, Callback_Server_getChannelState __cb)
    {
        return begin_getChannelState(channelid, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_getChannelState(int channelid, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__getChannelState_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __getChannelState_name, __cb);
        try
        {
            __result.__prepare(__getChannelState_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.writeInt(channelid);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param __ret (return value) State of channel.
     **/
    public Channel end_getChannelState(Ice.AsyncResult __result)
        throws InvalidChannelException,
               InvalidSecretException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __getChannelState_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidChannelException __ex)
            {
                throw __ex;
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        Channel __ret;
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        __ret = new Channel();
        __ret.__read(__is);
        __is.endReadEncaps();
        return __ret;
    }

    /**
     * Fetch all channels. This returns all defined channels on the server. The root channel is always channel 0.
     * @return List of defined channels.
     * @see getChannelState
     **/
    public java.util.Map<java.lang.Integer, Channel>
    getChannels()
        throws InvalidSecretException,
               ServerBootedException
    {
        return getChannels(null, false);
    }

    /**
     * Fetch all channels. This returns all defined channels on the server. The root channel is always channel 0.
     * @param __ctx The Context map to send with the invocation.
     * @return List of defined channels.
     * @see getChannelState
     **/
    public java.util.Map<java.lang.Integer, Channel>
    getChannels(java.util.Map<String, String> __ctx)
        throws InvalidSecretException,
               ServerBootedException
    {
        return getChannels(__ctx, true);
    }

    private java.util.Map<java.lang.Integer, Channel>
    getChannels(java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("getChannels");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                return __del.getChannels(__ctx);
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __getChannels_name = "getChannels";

    /**
     * Fetch all channels. This returns all defined channels on the server. The root channel is always channel 0.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getChannels()
    {
        return begin_getChannels(null, false, null);
    }

    /**
     * Fetch all channels. This returns all defined channels on the server. The root channel is always channel 0.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getChannels(java.util.Map<String, String> __ctx)
    {
        return begin_getChannels(__ctx, true, null);
    }

    /**
     * Fetch all channels. This returns all defined channels on the server. The root channel is always channel 0.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getChannels(Ice.Callback __cb)
    {
        return begin_getChannels(null, false, __cb);
    }

    /**
     * Fetch all channels. This returns all defined channels on the server. The root channel is always channel 0.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getChannels(java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_getChannels(__ctx, true, __cb);
    }

    /**
     * Fetch all channels. This returns all defined channels on the server. The root channel is always channel 0.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getChannels(Callback_Server_getChannels __cb)
    {
        return begin_getChannels(null, false, __cb);
    }

    /**
     * Fetch all channels. This returns all defined channels on the server. The root channel is always channel 0.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getChannels(java.util.Map<String, String> __ctx, Callback_Server_getChannels __cb)
    {
        return begin_getChannels(__ctx, true, __cb);
    }

    private Ice.AsyncResult begin_getChannels(java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__getChannels_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __getChannels_name, __cb);
        try
        {
            __result.__prepare(__getChannels_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param __ret (return value) List of defined channels.
     **/
    public java.util.Map<java.lang.Integer, Channel> end_getChannels(Ice.AsyncResult __result)
        throws InvalidSecretException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __getChannels_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        java.util.Map<java.lang.Integer, Channel> __ret;
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        __ret = ChannelMapHelper.read(__is);
        __is.endReadEncaps();
        return __ret;
    }

    /**
     * Retrieve configuration item.
     * @param key Configuration key.
     * @return Configuration value. If this is empty, see {@link Meta.getDefaultConf}
     **/
    public String
    getConf(String key)
        throws InvalidSecretException
    {
        return getConf(key, null, false);
    }

    /**
     * Retrieve configuration item.
     * @param key Configuration key.
     * @param __ctx The Context map to send with the invocation.
     * @return Configuration value. If this is empty, see {@link Meta.getDefaultConf}
     **/
    public String
    getConf(String key, java.util.Map<String, String> __ctx)
        throws InvalidSecretException
    {
        return getConf(key, __ctx, true);
    }

    private String
    getConf(String key, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("getConf");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                return __del.getConf(key, __ctx);
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __getConf_name = "getConf";

    /**
     * Retrieve configuration item.
     * @param __cb The callback object for the operation.
     * @param key Configuration key.
     **/
    public Ice.AsyncResult begin_getConf(String key)
    {
        return begin_getConf(key, null, false, null);
    }

    /**
     * Retrieve configuration item.
     * @param __cb The callback object for the operation.
     * @param key Configuration key.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getConf(String key, java.util.Map<String, String> __ctx)
    {
        return begin_getConf(key, __ctx, true, null);
    }

    /**
     * Retrieve configuration item.
     * @param __cb The callback object for the operation.
     * @param key Configuration key.
     **/
    public Ice.AsyncResult begin_getConf(String key, Ice.Callback __cb)
    {
        return begin_getConf(key, null, false, __cb);
    }

    /**
     * Retrieve configuration item.
     * @param __cb The callback object for the operation.
     * @param key Configuration key.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getConf(String key, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_getConf(key, __ctx, true, __cb);
    }

    /**
     * Retrieve configuration item.
     * @param __cb The callback object for the operation.
     * @param key Configuration key.
     **/
    public Ice.AsyncResult begin_getConf(String key, Callback_Server_getConf __cb)
    {
        return begin_getConf(key, null, false, __cb);
    }

    /**
     * Retrieve configuration item.
     * @param __cb The callback object for the operation.
     * @param key Configuration key.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getConf(String key, java.util.Map<String, String> __ctx, Callback_Server_getConf __cb)
    {
        return begin_getConf(key, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_getConf(String key, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__getConf_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __getConf_name, __cb);
        try
        {
            __result.__prepare(__getConf_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.writeString(key);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param __ret (return value) Configuration value. If this is empty, see {@link Meta.getDefaultConf}
     **/
    public String end_getConf(Ice.AsyncResult __result)
        throws InvalidSecretException
    {
        Ice.AsyncResult.__check(__result, this, __getConf_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        String __ret;
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        __ret = __is.readString();
        __is.endReadEncaps();
        return __ret;
    }

    /**
     * Fetch log entries.
     * @param first Lowest numbered entry to fetch. 0 is the most recent item.
     * @param last Last entry to fetch.
     * @return List of log entries.
     **/
    public LogEntry[]
    getLog(int first, int last)
        throws InvalidSecretException
    {
        return getLog(first, last, null, false);
    }

    /**
     * Fetch log entries.
     * @param first Lowest numbered entry to fetch. 0 is the most recent item.
     * @param last Last entry to fetch.
     * @param __ctx The Context map to send with the invocation.
     * @return List of log entries.
     **/
    public LogEntry[]
    getLog(int first, int last, java.util.Map<String, String> __ctx)
        throws InvalidSecretException
    {
        return getLog(first, last, __ctx, true);
    }

    private LogEntry[]
    getLog(int first, int last, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("getLog");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                return __del.getLog(first, last, __ctx);
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __getLog_name = "getLog";

    /**
     * Fetch log entries.
     * @param __cb The callback object for the operation.
     * @param first Lowest numbered entry to fetch. 0 is the most recent item.
     **/
    public Ice.AsyncResult begin_getLog(int first, int last)
    {
        return begin_getLog(first, last, null, false, null);
    }

    /**
     * Fetch log entries.
     * @param __cb The callback object for the operation.
     * @param first Lowest numbered entry to fetch. 0 is the most recent item.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getLog(int first, int last, java.util.Map<String, String> __ctx)
    {
        return begin_getLog(first, last, __ctx, true, null);
    }

    /**
     * Fetch log entries.
     * @param __cb The callback object for the operation.
     * @param first Lowest numbered entry to fetch. 0 is the most recent item.
     **/
    public Ice.AsyncResult begin_getLog(int first, int last, Ice.Callback __cb)
    {
        return begin_getLog(first, last, null, false, __cb);
    }

    /**
     * Fetch log entries.
     * @param __cb The callback object for the operation.
     * @param first Lowest numbered entry to fetch. 0 is the most recent item.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getLog(int first, int last, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_getLog(first, last, __ctx, true, __cb);
    }

    /**
     * Fetch log entries.
     * @param __cb The callback object for the operation.
     * @param first Lowest numbered entry to fetch. 0 is the most recent item.
     **/
    public Ice.AsyncResult begin_getLog(int first, int last, Callback_Server_getLog __cb)
    {
        return begin_getLog(first, last, null, false, __cb);
    }

    /**
     * Fetch log entries.
     * @param __cb The callback object for the operation.
     * @param first Lowest numbered entry to fetch. 0 is the most recent item.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getLog(int first, int last, java.util.Map<String, String> __ctx, Callback_Server_getLog __cb)
    {
        return begin_getLog(first, last, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_getLog(int first, int last, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__getLog_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __getLog_name, __cb);
        try
        {
            __result.__prepare(__getLog_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.writeInt(first);
            __os.writeInt(last);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param __ret (return value) List of log entries.
     **/
    public LogEntry[] end_getLog(Ice.AsyncResult __result)
        throws InvalidSecretException
    {
        Ice.AsyncResult.__check(__result, this, __getLog_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        LogEntry[] __ret;
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        __ret = LogListHelper.read(__is);
        __is.endReadEncaps();
        return __ret;
    }

    /**
     * Fetch length of log
     * @return Number of entries in log
     **/
    public int
    getLogLen()
        throws InvalidSecretException
    {
        return getLogLen(null, false);
    }

    /**
     * Fetch length of log
     * @param __ctx The Context map to send with the invocation.
     * @return Number of entries in log
     **/
    public int
    getLogLen(java.util.Map<String, String> __ctx)
        throws InvalidSecretException
    {
        return getLogLen(__ctx, true);
    }

    private int
    getLogLen(java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("getLogLen");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                return __del.getLogLen(__ctx);
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __getLogLen_name = "getLogLen";

    /**
     * Fetch length of log
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getLogLen()
    {
        return begin_getLogLen(null, false, null);
    }

    /**
     * Fetch length of log
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getLogLen(java.util.Map<String, String> __ctx)
    {
        return begin_getLogLen(__ctx, true, null);
    }

    /**
     * Fetch length of log
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getLogLen(Ice.Callback __cb)
    {
        return begin_getLogLen(null, false, __cb);
    }

    /**
     * Fetch length of log
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getLogLen(java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_getLogLen(__ctx, true, __cb);
    }

    /**
     * Fetch length of log
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getLogLen(Callback_Server_getLogLen __cb)
    {
        return begin_getLogLen(null, false, __cb);
    }

    /**
     * Fetch length of log
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getLogLen(java.util.Map<String, String> __ctx, Callback_Server_getLogLen __cb)
    {
        return begin_getLogLen(__ctx, true, __cb);
    }

    private Ice.AsyncResult begin_getLogLen(java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__getLogLen_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __getLogLen_name, __cb);
        try
        {
            __result.__prepare(__getLogLen_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param __ret (return value) Number of entries in log
     **/
    public int end_getLogLen(Ice.AsyncResult __result)
        throws InvalidSecretException
    {
        Ice.AsyncResult.__check(__result, this, __getLogLen_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        int __ret;
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        __ret = __is.readInt();
        __is.endReadEncaps();
        return __ret;
    }

    /**
     * Fetch a group of registered users.
     * @param filter Substring of user name. If blank, will retrieve all registered users.
     * @return List of registration records.
     **/
    public java.util.Map<java.lang.Integer, java.lang.String>
    getRegisteredUsers(String filter)
        throws InvalidSecretException,
               ServerBootedException
    {
        return getRegisteredUsers(filter, null, false);
    }

    /**
     * Fetch a group of registered users.
     * @param filter Substring of user name. If blank, will retrieve all registered users.
     * @param __ctx The Context map to send with the invocation.
     * @return List of registration records.
     **/
    public java.util.Map<java.lang.Integer, java.lang.String>
    getRegisteredUsers(String filter, java.util.Map<String, String> __ctx)
        throws InvalidSecretException,
               ServerBootedException
    {
        return getRegisteredUsers(filter, __ctx, true);
    }

    private java.util.Map<java.lang.Integer, java.lang.String>
    getRegisteredUsers(String filter, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("getRegisteredUsers");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                return __del.getRegisteredUsers(filter, __ctx);
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __getRegisteredUsers_name = "getRegisteredUsers";

    /**
     * Fetch a group of registered users.
     * @param __cb The callback object for the operation.
     * @param filter Substring of user name. If blank, will retrieve all registered users.
     **/
    public Ice.AsyncResult begin_getRegisteredUsers(String filter)
    {
        return begin_getRegisteredUsers(filter, null, false, null);
    }

    /**
     * Fetch a group of registered users.
     * @param __cb The callback object for the operation.
     * @param filter Substring of user name. If blank, will retrieve all registered users.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getRegisteredUsers(String filter, java.util.Map<String, String> __ctx)
    {
        return begin_getRegisteredUsers(filter, __ctx, true, null);
    }

    /**
     * Fetch a group of registered users.
     * @param __cb The callback object for the operation.
     * @param filter Substring of user name. If blank, will retrieve all registered users.
     **/
    public Ice.AsyncResult begin_getRegisteredUsers(String filter, Ice.Callback __cb)
    {
        return begin_getRegisteredUsers(filter, null, false, __cb);
    }

    /**
     * Fetch a group of registered users.
     * @param __cb The callback object for the operation.
     * @param filter Substring of user name. If blank, will retrieve all registered users.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getRegisteredUsers(String filter, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_getRegisteredUsers(filter, __ctx, true, __cb);
    }

    /**
     * Fetch a group of registered users.
     * @param __cb The callback object for the operation.
     * @param filter Substring of user name. If blank, will retrieve all registered users.
     **/
    public Ice.AsyncResult begin_getRegisteredUsers(String filter, Callback_Server_getRegisteredUsers __cb)
    {
        return begin_getRegisteredUsers(filter, null, false, __cb);
    }

    /**
     * Fetch a group of registered users.
     * @param __cb The callback object for the operation.
     * @param filter Substring of user name. If blank, will retrieve all registered users.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getRegisteredUsers(String filter, java.util.Map<String, String> __ctx, Callback_Server_getRegisteredUsers __cb)
    {
        return begin_getRegisteredUsers(filter, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_getRegisteredUsers(String filter, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__getRegisteredUsers_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __getRegisteredUsers_name, __cb);
        try
        {
            __result.__prepare(__getRegisteredUsers_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.writeString(filter);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param __ret (return value) List of registration records.
     **/
    public java.util.Map<java.lang.Integer, java.lang.String> end_getRegisteredUsers(Ice.AsyncResult __result)
        throws InvalidSecretException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __getRegisteredUsers_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        java.util.Map<java.lang.Integer, java.lang.String> __ret;
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        __ret = NameMapHelper.read(__is);
        __is.endReadEncaps();
        return __ret;
    }

    /**
     * Fetch registration for a single user.
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     * @return Registration record.
     **/
    public java.util.Map<UserInfo, java.lang.String>
    getRegistration(int userid)
        throws InvalidSecretException,
               InvalidUserException,
               ServerBootedException
    {
        return getRegistration(userid, null, false);
    }

    /**
     * Fetch registration for a single user.
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     * @param __ctx The Context map to send with the invocation.
     * @return Registration record.
     **/
    public java.util.Map<UserInfo, java.lang.String>
    getRegistration(int userid, java.util.Map<String, String> __ctx)
        throws InvalidSecretException,
               InvalidUserException,
               ServerBootedException
    {
        return getRegistration(userid, __ctx, true);
    }

    private java.util.Map<UserInfo, java.lang.String>
    getRegistration(int userid, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException,
               InvalidUserException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("getRegistration");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                return __del.getRegistration(userid, __ctx);
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __getRegistration_name = "getRegistration";

    /**
     * Fetch registration for a single user.
     * @param __cb The callback object for the operation.
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     **/
    public Ice.AsyncResult begin_getRegistration(int userid)
    {
        return begin_getRegistration(userid, null, false, null);
    }

    /**
     * Fetch registration for a single user.
     * @param __cb The callback object for the operation.
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getRegistration(int userid, java.util.Map<String, String> __ctx)
    {
        return begin_getRegistration(userid, __ctx, true, null);
    }

    /**
     * Fetch registration for a single user.
     * @param __cb The callback object for the operation.
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     **/
    public Ice.AsyncResult begin_getRegistration(int userid, Ice.Callback __cb)
    {
        return begin_getRegistration(userid, null, false, __cb);
    }

    /**
     * Fetch registration for a single user.
     * @param __cb The callback object for the operation.
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getRegistration(int userid, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_getRegistration(userid, __ctx, true, __cb);
    }

    /**
     * Fetch registration for a single user.
     * @param __cb The callback object for the operation.
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     **/
    public Ice.AsyncResult begin_getRegistration(int userid, Callback_Server_getRegistration __cb)
    {
        return begin_getRegistration(userid, null, false, __cb);
    }

    /**
     * Fetch registration for a single user.
     * @param __cb The callback object for the operation.
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getRegistration(int userid, java.util.Map<String, String> __ctx, Callback_Server_getRegistration __cb)
    {
        return begin_getRegistration(userid, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_getRegistration(int userid, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__getRegistration_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __getRegistration_name, __cb);
        try
        {
            __result.__prepare(__getRegistration_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.writeInt(userid);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param __ret (return value) Registration record.
     **/
    public java.util.Map<UserInfo, java.lang.String> end_getRegistration(Ice.AsyncResult __result)
        throws InvalidSecretException,
               InvalidUserException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __getRegistration_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(InvalidUserException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        java.util.Map<UserInfo, java.lang.String> __ret;
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        __ret = UserInfoMapHelper.read(__is);
        __is.endReadEncaps();
        return __ret;
    }

    /**
     * Get state of a single connected user. 
     * @param session Connection ID of user. See {@link User.session}.
     * @return State of connected user.
     * @see setState
     * @see getUsers
     **/
    public User
    getState(int session)
        throws InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        return getState(session, null, false);
    }

    /**
     * Get state of a single connected user. 
     * @param session Connection ID of user. See {@link User.session}.
     * @param __ctx The Context map to send with the invocation.
     * @return State of connected user.
     * @see setState
     * @see getUsers
     **/
    public User
    getState(int session, java.util.Map<String, String> __ctx)
        throws InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        return getState(session, __ctx, true);
    }

    private User
    getState(int session, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("getState");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                return __del.getState(session, __ctx);
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __getState_name = "getState";

    /**
     * Get state of a single connected user. 
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     **/
    public Ice.AsyncResult begin_getState(int session)
    {
        return begin_getState(session, null, false, null);
    }

    /**
     * Get state of a single connected user. 
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getState(int session, java.util.Map<String, String> __ctx)
    {
        return begin_getState(session, __ctx, true, null);
    }

    /**
     * Get state of a single connected user. 
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     **/
    public Ice.AsyncResult begin_getState(int session, Ice.Callback __cb)
    {
        return begin_getState(session, null, false, __cb);
    }

    /**
     * Get state of a single connected user. 
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getState(int session, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_getState(session, __ctx, true, __cb);
    }

    /**
     * Get state of a single connected user. 
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     **/
    public Ice.AsyncResult begin_getState(int session, Callback_Server_getState __cb)
    {
        return begin_getState(session, null, false, __cb);
    }

    /**
     * Get state of a single connected user. 
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getState(int session, java.util.Map<String, String> __ctx, Callback_Server_getState __cb)
    {
        return begin_getState(session, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_getState(int session, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__getState_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __getState_name, __cb);
        try
        {
            __result.__prepare(__getState_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.writeInt(session);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param __ret (return value) State of connected user.
     **/
    public User end_getState(Ice.AsyncResult __result)
        throws InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __getState_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(InvalidSessionException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        User __ret;
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        __ret = new User();
        __ret.__read(__is);
        __is.endReadEncaps();
        return __ret;
    }

    /**
     * Fetch user texture. Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     * @return Custom texture associated with user or an empty texture.
     **/
    public byte[]
    getTexture(int userid)
        throws InvalidSecretException,
               InvalidUserException,
               ServerBootedException
    {
        return getTexture(userid, null, false);
    }

    /**
     * Fetch user texture. Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     * @param __ctx The Context map to send with the invocation.
     * @return Custom texture associated with user or an empty texture.
     **/
    public byte[]
    getTexture(int userid, java.util.Map<String, String> __ctx)
        throws InvalidSecretException,
               InvalidUserException,
               ServerBootedException
    {
        return getTexture(userid, __ctx, true);
    }

    private byte[]
    getTexture(int userid, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException,
               InvalidUserException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("getTexture");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                return __del.getTexture(userid, __ctx);
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __getTexture_name = "getTexture";

    /**
     * Fetch user texture. Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
     * @param __cb The callback object for the operation.
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     **/
    public Ice.AsyncResult begin_getTexture(int userid)
    {
        return begin_getTexture(userid, null, false, null);
    }

    /**
     * Fetch user texture. Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
     * @param __cb The callback object for the operation.
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getTexture(int userid, java.util.Map<String, String> __ctx)
    {
        return begin_getTexture(userid, __ctx, true, null);
    }

    /**
     * Fetch user texture. Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
     * @param __cb The callback object for the operation.
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     **/
    public Ice.AsyncResult begin_getTexture(int userid, Ice.Callback __cb)
    {
        return begin_getTexture(userid, null, false, __cb);
    }

    /**
     * Fetch user texture. Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
     * @param __cb The callback object for the operation.
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getTexture(int userid, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_getTexture(userid, __ctx, true, __cb);
    }

    /**
     * Fetch user texture. Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
     * @param __cb The callback object for the operation.
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     **/
    public Ice.AsyncResult begin_getTexture(int userid, Callback_Server_getTexture __cb)
    {
        return begin_getTexture(userid, null, false, __cb);
    }

    /**
     * Fetch user texture. Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
     * @param __cb The callback object for the operation.
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getTexture(int userid, java.util.Map<String, String> __ctx, Callback_Server_getTexture __cb)
    {
        return begin_getTexture(userid, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_getTexture(int userid, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__getTexture_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __getTexture_name, __cb);
        try
        {
            __result.__prepare(__getTexture_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.writeInt(userid);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param __ret (return value) Custom texture associated with user or an empty texture.
     **/
    public byte[] end_getTexture(Ice.AsyncResult __result)
        throws InvalidSecretException,
               InvalidUserException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __getTexture_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(InvalidUserException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        byte[] __ret;
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        __ret = TextureHelper.read(__is);
        __is.endReadEncaps();
        return __ret;
    }

    /**
     * Fetch all channels and connected users as a tree. This retrieves an easy-to-use representation of the server
     * as a tree. This is primarily used for viewing the state of the server on a webpage.
     * @return Recursive tree of all channels and connected users.
     **/
    public Tree
    getTree()
        throws InvalidSecretException,
               ServerBootedException
    {
        return getTree(null, false);
    }

    /**
     * Fetch all channels and connected users as a tree. This retrieves an easy-to-use representation of the server
     * as a tree. This is primarily used for viewing the state of the server on a webpage.
     * @param __ctx The Context map to send with the invocation.
     * @return Recursive tree of all channels and connected users.
     **/
    public Tree
    getTree(java.util.Map<String, String> __ctx)
        throws InvalidSecretException,
               ServerBootedException
    {
        return getTree(__ctx, true);
    }

    private Tree
    getTree(java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("getTree");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                return __del.getTree(__ctx);
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __getTree_name = "getTree";

    /**
     * Fetch all channels and connected users as a tree. This retrieves an easy-to-use representation of the server
     * as a tree. This is primarily used for viewing the state of the server on a webpage.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getTree()
    {
        return begin_getTree(null, false, null);
    }

    /**
     * Fetch all channels and connected users as a tree. This retrieves an easy-to-use representation of the server
     * as a tree. This is primarily used for viewing the state of the server on a webpage.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getTree(java.util.Map<String, String> __ctx)
    {
        return begin_getTree(__ctx, true, null);
    }

    /**
     * Fetch all channels and connected users as a tree. This retrieves an easy-to-use representation of the server
     * as a tree. This is primarily used for viewing the state of the server on a webpage.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getTree(Ice.Callback __cb)
    {
        return begin_getTree(null, false, __cb);
    }

    /**
     * Fetch all channels and connected users as a tree. This retrieves an easy-to-use representation of the server
     * as a tree. This is primarily used for viewing the state of the server on a webpage.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getTree(java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_getTree(__ctx, true, __cb);
    }

    /**
     * Fetch all channels and connected users as a tree. This retrieves an easy-to-use representation of the server
     * as a tree. This is primarily used for viewing the state of the server on a webpage.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getTree(Callback_Server_getTree __cb)
    {
        return begin_getTree(null, false, __cb);
    }

    /**
     * Fetch all channels and connected users as a tree. This retrieves an easy-to-use representation of the server
     * as a tree. This is primarily used for viewing the state of the server on a webpage.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getTree(java.util.Map<String, String> __ctx, Callback_Server_getTree __cb)
    {
        return begin_getTree(__ctx, true, __cb);
    }

    private Ice.AsyncResult begin_getTree(java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__getTree_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __getTree_name, __cb);
        try
        {
            __result.__prepare(__getTree_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param __ret (return value) Recursive tree of all channels and connected users.
     **/
    public Tree end_getTree(Ice.AsyncResult __result)
        throws InvalidSecretException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __getTree_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        TreeHolder __ret = new TreeHolder();
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        __is.readObject(__ret);
        __is.readPendingObjects();
        __is.endReadEncaps();
        return __ret.value;
    }

    /**
     * Get virtual server uptime.
     * @return Uptime of the virtual server in seconds
     **/
    public int
    getUptime()
        throws InvalidSecretException,
               ServerBootedException
    {
        return getUptime(null, false);
    }

    /**
     * Get virtual server uptime.
     * @param __ctx The Context map to send with the invocation.
     * @return Uptime of the virtual server in seconds
     **/
    public int
    getUptime(java.util.Map<String, String> __ctx)
        throws InvalidSecretException,
               ServerBootedException
    {
        return getUptime(__ctx, true);
    }

    private int
    getUptime(java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("getUptime");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                return __del.getUptime(__ctx);
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __getUptime_name = "getUptime";

    /**
     * Get virtual server uptime.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getUptime()
    {
        return begin_getUptime(null, false, null);
    }

    /**
     * Get virtual server uptime.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getUptime(java.util.Map<String, String> __ctx)
    {
        return begin_getUptime(__ctx, true, null);
    }

    /**
     * Get virtual server uptime.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getUptime(Ice.Callback __cb)
    {
        return begin_getUptime(null, false, __cb);
    }

    /**
     * Get virtual server uptime.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getUptime(java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_getUptime(__ctx, true, __cb);
    }

    /**
     * Get virtual server uptime.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getUptime(Callback_Server_getUptime __cb)
    {
        return begin_getUptime(null, false, __cb);
    }

    /**
     * Get virtual server uptime.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getUptime(java.util.Map<String, String> __ctx, Callback_Server_getUptime __cb)
    {
        return begin_getUptime(__ctx, true, __cb);
    }

    private Ice.AsyncResult begin_getUptime(java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__getUptime_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __getUptime_name, __cb);
        try
        {
            __result.__prepare(__getUptime_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param __ret (return value) Uptime of the virtual server in seconds
     **/
    public int end_getUptime(Ice.AsyncResult __result)
        throws InvalidSecretException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __getUptime_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        int __ret;
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        __ret = __is.readInt();
        __is.endReadEncaps();
        return __ret;
    }

    /**
     * Map a list of user names to a matching id.
     * @param List of names.
     * @reuturn List of matching ids, with -1 representing invalid or unknown user names.
     **/
    public java.util.Map<java.lang.String, java.lang.Integer>
    getUserIds(String[] names)
        throws InvalidSecretException,
               ServerBootedException
    {
        return getUserIds(names, null, false);
    }

    /**
     * Map a list of user names to a matching id.
     * @param List of names.
     * @reuturn List of matching ids, with -1 representing invalid or unknown user names.
     * @param __ctx The Context map to send with the invocation.
     **/
    public java.util.Map<java.lang.String, java.lang.Integer>
    getUserIds(String[] names, java.util.Map<String, String> __ctx)
        throws InvalidSecretException,
               ServerBootedException
    {
        return getUserIds(names, __ctx, true);
    }

    private java.util.Map<java.lang.String, java.lang.Integer>
    getUserIds(String[] names, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("getUserIds");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                return __del.getUserIds(names, __ctx);
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __getUserIds_name = "getUserIds";

    /**
     * Map a list of user names to a matching id.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getUserIds(String[] names)
    {
        return begin_getUserIds(names, null, false, null);
    }

    /**
     * Map a list of user names to a matching id.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getUserIds(String[] names, java.util.Map<String, String> __ctx)
    {
        return begin_getUserIds(names, __ctx, true, null);
    }

    /**
     * Map a list of user names to a matching id.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getUserIds(String[] names, Ice.Callback __cb)
    {
        return begin_getUserIds(names, null, false, __cb);
    }

    /**
     * Map a list of user names to a matching id.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getUserIds(String[] names, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_getUserIds(names, __ctx, true, __cb);
    }

    /**
     * Map a list of user names to a matching id.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getUserIds(String[] names, Callback_Server_getUserIds __cb)
    {
        return begin_getUserIds(names, null, false, __cb);
    }

    /**
     * Map a list of user names to a matching id.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getUserIds(String[] names, java.util.Map<String, String> __ctx, Callback_Server_getUserIds __cb)
    {
        return begin_getUserIds(names, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_getUserIds(String[] names, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__getUserIds_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __getUserIds_name, __cb);
        try
        {
            __result.__prepare(__getUserIds_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            NameListHelper.write(__os, names);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     **/
    public java.util.Map<java.lang.String, java.lang.Integer> end_getUserIds(Ice.AsyncResult __result)
        throws InvalidSecretException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __getUserIds_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        java.util.Map<java.lang.String, java.lang.Integer> __ret;
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        __ret = IdMapHelper.read(__is);
        __is.endReadEncaps();
        return __ret;
    }

    /**
     * Map a list of {@link User.userid} to a matching name.
     * @param List of ids.
     * @return Matching list of names, with an empty string representing invalid or unknown ids.
     **/
    public java.util.Map<java.lang.Integer, java.lang.String>
    getUserNames(int[] ids)
        throws InvalidSecretException,
               ServerBootedException
    {
        return getUserNames(ids, null, false);
    }

    /**
     * Map a list of {@link User.userid} to a matching name.
     * @param List of ids.
     * @param __ctx The Context map to send with the invocation.
     * @return Matching list of names, with an empty string representing invalid or unknown ids.
     **/
    public java.util.Map<java.lang.Integer, java.lang.String>
    getUserNames(int[] ids, java.util.Map<String, String> __ctx)
        throws InvalidSecretException,
               ServerBootedException
    {
        return getUserNames(ids, __ctx, true);
    }

    private java.util.Map<java.lang.Integer, java.lang.String>
    getUserNames(int[] ids, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("getUserNames");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                return __del.getUserNames(ids, __ctx);
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __getUserNames_name = "getUserNames";

    /**
     * Map a list of {@link User.userid} to a matching name.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getUserNames(int[] ids)
    {
        return begin_getUserNames(ids, null, false, null);
    }

    /**
     * Map a list of {@link User.userid} to a matching name.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getUserNames(int[] ids, java.util.Map<String, String> __ctx)
    {
        return begin_getUserNames(ids, __ctx, true, null);
    }

    /**
     * Map a list of {@link User.userid} to a matching name.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getUserNames(int[] ids, Ice.Callback __cb)
    {
        return begin_getUserNames(ids, null, false, __cb);
    }

    /**
     * Map a list of {@link User.userid} to a matching name.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getUserNames(int[] ids, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_getUserNames(ids, __ctx, true, __cb);
    }

    /**
     * Map a list of {@link User.userid} to a matching name.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getUserNames(int[] ids, Callback_Server_getUserNames __cb)
    {
        return begin_getUserNames(ids, null, false, __cb);
    }

    /**
     * Map a list of {@link User.userid} to a matching name.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getUserNames(int[] ids, java.util.Map<String, String> __ctx, Callback_Server_getUserNames __cb)
    {
        return begin_getUserNames(ids, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_getUserNames(int[] ids, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__getUserNames_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __getUserNames_name, __cb);
        try
        {
            __result.__prepare(__getUserNames_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            IdListHelper.write(__os, ids);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param __ret (return value) Matching list of names, with an empty string representing invalid or unknown ids.
     **/
    public java.util.Map<java.lang.Integer, java.lang.String> end_getUserNames(Ice.AsyncResult __result)
        throws InvalidSecretException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __getUserNames_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        java.util.Map<java.lang.Integer, java.lang.String> __ret;
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        __ret = NameMapHelper.read(__is);
        __is.endReadEncaps();
        return __ret;
    }

    /**
     * Fetch all users. This returns all currently connected users on the server.
     * @return List of connected users.
     * @see getState
     **/
    public java.util.Map<java.lang.Integer, User>
    getUsers()
        throws InvalidSecretException,
               ServerBootedException
    {
        return getUsers(null, false);
    }

    /**
     * Fetch all users. This returns all currently connected users on the server.
     * @param __ctx The Context map to send with the invocation.
     * @return List of connected users.
     * @see getState
     **/
    public java.util.Map<java.lang.Integer, User>
    getUsers(java.util.Map<String, String> __ctx)
        throws InvalidSecretException,
               ServerBootedException
    {
        return getUsers(__ctx, true);
    }

    private java.util.Map<java.lang.Integer, User>
    getUsers(java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("getUsers");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                return __del.getUsers(__ctx);
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __getUsers_name = "getUsers";

    /**
     * Fetch all users. This returns all currently connected users on the server.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getUsers()
    {
        return begin_getUsers(null, false, null);
    }

    /**
     * Fetch all users. This returns all currently connected users on the server.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getUsers(java.util.Map<String, String> __ctx)
    {
        return begin_getUsers(__ctx, true, null);
    }

    /**
     * Fetch all users. This returns all currently connected users on the server.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getUsers(Ice.Callback __cb)
    {
        return begin_getUsers(null, false, __cb);
    }

    /**
     * Fetch all users. This returns all currently connected users on the server.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getUsers(java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_getUsers(__ctx, true, __cb);
    }

    /**
     * Fetch all users. This returns all currently connected users on the server.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getUsers(Callback_Server_getUsers __cb)
    {
        return begin_getUsers(null, false, __cb);
    }

    /**
     * Fetch all users. This returns all currently connected users on the server.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getUsers(java.util.Map<String, String> __ctx, Callback_Server_getUsers __cb)
    {
        return begin_getUsers(__ctx, true, __cb);
    }

    private Ice.AsyncResult begin_getUsers(java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__getUsers_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __getUsers_name, __cb);
        try
        {
            __result.__prepare(__getUsers_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param __ret (return value) List of connected users.
     **/
    public java.util.Map<java.lang.Integer, User> end_getUsers(Ice.AsyncResult __result)
        throws InvalidSecretException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __getUsers_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        java.util.Map<java.lang.Integer, User> __ret;
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        __ret = UserMapHelper.read(__is);
        __is.endReadEncaps();
        return __ret;
    }

    /**
     * Check if user is permitted to perform action.
     * @param session Connection ID of user. See {@link User.session}.
     * @param channelid ID of Channel. See {@link Channel.id}.
     * @param perm Permission bits to check.
     * @return true if any of the permissions in perm were set for the user.
     **/
    public boolean
    hasPermission(int session, int channelid, int perm)
        throws InvalidChannelException,
               InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        return hasPermission(session, channelid, perm, null, false);
    }

    /**
     * Check if user is permitted to perform action.
     * @param session Connection ID of user. See {@link User.session}.
     * @param channelid ID of Channel. See {@link Channel.id}.
     * @param perm Permission bits to check.
     * @param __ctx The Context map to send with the invocation.
     * @return true if any of the permissions in perm were set for the user.
     **/
    public boolean
    hasPermission(int session, int channelid, int perm, java.util.Map<String, String> __ctx)
        throws InvalidChannelException,
               InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        return hasPermission(session, channelid, perm, __ctx, true);
    }

    private boolean
    hasPermission(int session, int channelid, int perm, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidChannelException,
               InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("hasPermission");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                return __del.hasPermission(session, channelid, perm, __ctx);
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __handleExceptionWrapper(__delBase, __ex);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __hasPermission_name = "hasPermission";

    /**
     * Check if user is permitted to perform action.
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     * @param perm Permission bits to check.
     **/
    public Ice.AsyncResult begin_hasPermission(int session, int channelid, int perm)
    {
        return begin_hasPermission(session, channelid, perm, null, false, null);
    }

    /**
     * Check if user is permitted to perform action.
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     * @param perm Permission bits to check.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_hasPermission(int session, int channelid, int perm, java.util.Map<String, String> __ctx)
    {
        return begin_hasPermission(session, channelid, perm, __ctx, true, null);
    }

    /**
     * Check if user is permitted to perform action.
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     * @param perm Permission bits to check.
     **/
    public Ice.AsyncResult begin_hasPermission(int session, int channelid, int perm, Ice.Callback __cb)
    {
        return begin_hasPermission(session, channelid, perm, null, false, __cb);
    }

    /**
     * Check if user is permitted to perform action.
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     * @param perm Permission bits to check.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_hasPermission(int session, int channelid, int perm, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_hasPermission(session, channelid, perm, __ctx, true, __cb);
    }

    /**
     * Check if user is permitted to perform action.
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     * @param perm Permission bits to check.
     **/
    public Ice.AsyncResult begin_hasPermission(int session, int channelid, int perm, Callback_Server_hasPermission __cb)
    {
        return begin_hasPermission(session, channelid, perm, null, false, __cb);
    }

    /**
     * Check if user is permitted to perform action.
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     * @param perm Permission bits to check.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_hasPermission(int session, int channelid, int perm, java.util.Map<String, String> __ctx, Callback_Server_hasPermission __cb)
    {
        return begin_hasPermission(session, channelid, perm, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_hasPermission(int session, int channelid, int perm, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__hasPermission_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __hasPermission_name, __cb);
        try
        {
            __result.__prepare(__hasPermission_name, Ice.OperationMode.Normal, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.writeInt(session);
            __os.writeInt(channelid);
            __os.writeInt(perm);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param __ret (return value) true if any of the permissions in perm were set for the user.
     **/
    public boolean end_hasPermission(Ice.AsyncResult __result)
        throws InvalidChannelException,
               InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __hasPermission_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidChannelException __ex)
            {
                throw __ex;
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(InvalidSessionException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        boolean __ret;
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        __ret = __is.readBool();
        __is.endReadEncaps();
        return __ret;
    }

    /**
     * Fetch the server id.
     * 
     * @return Unique server id.
     **/
    public int
    id()
        throws InvalidSecretException
    {
        return id(null, false);
    }

    /**
     * Fetch the server id.
     * 
     * @param __ctx The Context map to send with the invocation.
     * @return Unique server id.
     **/
    public int
    id(java.util.Map<String, String> __ctx)
        throws InvalidSecretException
    {
        return id(__ctx, true);
    }

    private int
    id(java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("id");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                return __del.id(__ctx);
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __id_name = "id";

    /**
     * Fetch the server id.
     * 
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_id()
    {
        return begin_id(null, false, null);
    }

    /**
     * Fetch the server id.
     * 
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_id(java.util.Map<String, String> __ctx)
    {
        return begin_id(__ctx, true, null);
    }

    /**
     * Fetch the server id.
     * 
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_id(Ice.Callback __cb)
    {
        return begin_id(null, false, __cb);
    }

    /**
     * Fetch the server id.
     * 
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_id(java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_id(__ctx, true, __cb);
    }

    /**
     * Fetch the server id.
     * 
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_id(Callback_Server_id __cb)
    {
        return begin_id(null, false, __cb);
    }

    /**
     * Fetch the server id.
     * 
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_id(java.util.Map<String, String> __ctx, Callback_Server_id __cb)
    {
        return begin_id(__ctx, true, __cb);
    }

    private Ice.AsyncResult begin_id(java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__id_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __id_name, __cb);
        try
        {
            __result.__prepare(__id_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param __ret (return value) Unique server id.
     **/
    public int end_id(Ice.AsyncResult __result)
        throws InvalidSecretException
    {
        Ice.AsyncResult.__check(__result, this, __id_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        int __ret;
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        __ret = __is.readInt();
        __is.endReadEncaps();
        return __ret;
    }

    /**
     * Shows if the server currently running (accepting users).
     * 
     * @return Run-state of server.
     **/
    public boolean
    isRunning()
        throws InvalidSecretException
    {
        return isRunning(null, false);
    }

    /**
     * Shows if the server currently running (accepting users).
     * 
     * @param __ctx The Context map to send with the invocation.
     * @return Run-state of server.
     **/
    public boolean
    isRunning(java.util.Map<String, String> __ctx)
        throws InvalidSecretException
    {
        return isRunning(__ctx, true);
    }

    private boolean
    isRunning(java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("isRunning");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                return __del.isRunning(__ctx);
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __isRunning_name = "isRunning";

    /**
     * Shows if the server currently running (accepting users).
     * 
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_isRunning()
    {
        return begin_isRunning(null, false, null);
    }

    /**
     * Shows if the server currently running (accepting users).
     * 
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_isRunning(java.util.Map<String, String> __ctx)
    {
        return begin_isRunning(__ctx, true, null);
    }

    /**
     * Shows if the server currently running (accepting users).
     * 
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_isRunning(Ice.Callback __cb)
    {
        return begin_isRunning(null, false, __cb);
    }

    /**
     * Shows if the server currently running (accepting users).
     * 
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_isRunning(java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_isRunning(__ctx, true, __cb);
    }

    /**
     * Shows if the server currently running (accepting users).
     * 
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_isRunning(Callback_Server_isRunning __cb)
    {
        return begin_isRunning(null, false, __cb);
    }

    /**
     * Shows if the server currently running (accepting users).
     * 
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_isRunning(java.util.Map<String, String> __ctx, Callback_Server_isRunning __cb)
    {
        return begin_isRunning(__ctx, true, __cb);
    }

    private Ice.AsyncResult begin_isRunning(java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__isRunning_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __isRunning_name, __cb);
        try
        {
            __result.__prepare(__isRunning_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param __ret (return value) Run-state of server.
     **/
    public boolean end_isRunning(Ice.AsyncResult __result)
        throws InvalidSecretException
    {
        Ice.AsyncResult.__check(__result, this, __isRunning_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        boolean __ret;
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        __ret = __is.readBool();
        __is.endReadEncaps();
        return __ret;
    }

    /**
     * Kick a user. The user is not banned, and is free to rejoin the server.
     * @param session Connection ID of user. See {@link User.session}.
     * @param reason Text message to show when user is kicked.
     **/
    public void
    kickUser(int session, String reason)
        throws InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        kickUser(session, reason, null, false);
    }

    /**
     * Kick a user. The user is not banned, and is free to rejoin the server.
     * @param session Connection ID of user. See {@link User.session}.
     * @param reason Text message to show when user is kicked.
     * @param __ctx The Context map to send with the invocation.
     **/
    public void
    kickUser(int session, String reason, java.util.Map<String, String> __ctx)
        throws InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        kickUser(session, reason, __ctx, true);
    }

    private void
    kickUser(int session, String reason, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("kickUser");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                __del.kickUser(session, reason, __ctx);
                return;
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __handleExceptionWrapper(__delBase, __ex);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __kickUser_name = "kickUser";

    /**
     * Kick a user. The user is not banned, and is free to rejoin the server.
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     **/
    public Ice.AsyncResult begin_kickUser(int session, String reason)
    {
        return begin_kickUser(session, reason, null, false, null);
    }

    /**
     * Kick a user. The user is not banned, and is free to rejoin the server.
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_kickUser(int session, String reason, java.util.Map<String, String> __ctx)
    {
        return begin_kickUser(session, reason, __ctx, true, null);
    }

    /**
     * Kick a user. The user is not banned, and is free to rejoin the server.
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     **/
    public Ice.AsyncResult begin_kickUser(int session, String reason, Ice.Callback __cb)
    {
        return begin_kickUser(session, reason, null, false, __cb);
    }

    /**
     * Kick a user. The user is not banned, and is free to rejoin the server.
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_kickUser(int session, String reason, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_kickUser(session, reason, __ctx, true, __cb);
    }

    /**
     * Kick a user. The user is not banned, and is free to rejoin the server.
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     **/
    public Ice.AsyncResult begin_kickUser(int session, String reason, Callback_Server_kickUser __cb)
    {
        return begin_kickUser(session, reason, null, false, __cb);
    }

    /**
     * Kick a user. The user is not banned, and is free to rejoin the server.
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_kickUser(int session, String reason, java.util.Map<String, String> __ctx, Callback_Server_kickUser __cb)
    {
        return begin_kickUser(session, reason, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_kickUser(int session, String reason, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__kickUser_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __kickUser_name, __cb);
        try
        {
            __result.__prepare(__kickUser_name, Ice.OperationMode.Normal, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.writeInt(session);
            __os.writeString(reason);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     **/
    public void end_kickUser(Ice.AsyncResult __result)
        throws InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __kickUser_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(InvalidSessionException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        IceInternal.BasicStream __is = __result.__is();
        __is.skipEmptyEncaps();
    }

    /**
     * Redirect whisper targets for user. If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
     * To remove a redirect pass an empty target string. This is intended for context groups.
     * @param session Connection ID of user. See {@link User.session}.
     * @param source Group name to redirect from.
     * @param target Group name to redirect to.
     **/
    public void
    redirectWhisperGroup(int session, String source, String target)
        throws InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        redirectWhisperGroup(session, source, target, null, false);
    }

    /**
     * Redirect whisper targets for user. If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
     * To remove a redirect pass an empty target string. This is intended for context groups.
     * @param session Connection ID of user. See {@link User.session}.
     * @param source Group name to redirect from.
     * @param target Group name to redirect to.
     * @param __ctx The Context map to send with the invocation.
     **/
    public void
    redirectWhisperGroup(int session, String source, String target, java.util.Map<String, String> __ctx)
        throws InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        redirectWhisperGroup(session, source, target, __ctx, true);
    }

    private void
    redirectWhisperGroup(int session, String source, String target, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("redirectWhisperGroup");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                __del.redirectWhisperGroup(session, source, target, __ctx);
                return;
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __redirectWhisperGroup_name = "redirectWhisperGroup";

    /**
     * Redirect whisper targets for user. If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
     * To remove a redirect pass an empty target string. This is intended for context groups.
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     * @param target Group name to redirect to.
     **/
    public Ice.AsyncResult begin_redirectWhisperGroup(int session, String source, String target)
    {
        return begin_redirectWhisperGroup(session, source, target, null, false, null);
    }

    /**
     * Redirect whisper targets for user. If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
     * To remove a redirect pass an empty target string. This is intended for context groups.
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     * @param target Group name to redirect to.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_redirectWhisperGroup(int session, String source, String target, java.util.Map<String, String> __ctx)
    {
        return begin_redirectWhisperGroup(session, source, target, __ctx, true, null);
    }

    /**
     * Redirect whisper targets for user. If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
     * To remove a redirect pass an empty target string. This is intended for context groups.
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     * @param target Group name to redirect to.
     **/
    public Ice.AsyncResult begin_redirectWhisperGroup(int session, String source, String target, Ice.Callback __cb)
    {
        return begin_redirectWhisperGroup(session, source, target, null, false, __cb);
    }

    /**
     * Redirect whisper targets for user. If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
     * To remove a redirect pass an empty target string. This is intended for context groups.
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     * @param target Group name to redirect to.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_redirectWhisperGroup(int session, String source, String target, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_redirectWhisperGroup(session, source, target, __ctx, true, __cb);
    }

    /**
     * Redirect whisper targets for user. If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
     * To remove a redirect pass an empty target string. This is intended for context groups.
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     * @param target Group name to redirect to.
     **/
    public Ice.AsyncResult begin_redirectWhisperGroup(int session, String source, String target, Callback_Server_redirectWhisperGroup __cb)
    {
        return begin_redirectWhisperGroup(session, source, target, null, false, __cb);
    }

    /**
     * Redirect whisper targets for user. If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
     * To remove a redirect pass an empty target string. This is intended for context groups.
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     * @param target Group name to redirect to.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_redirectWhisperGroup(int session, String source, String target, java.util.Map<String, String> __ctx, Callback_Server_redirectWhisperGroup __cb)
    {
        return begin_redirectWhisperGroup(session, source, target, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_redirectWhisperGroup(int session, String source, String target, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__redirectWhisperGroup_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __redirectWhisperGroup_name, __cb);
        try
        {
            __result.__prepare(__redirectWhisperGroup_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.writeInt(session);
            __os.writeString(source);
            __os.writeString(target);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     **/
    public void end_redirectWhisperGroup(Ice.AsyncResult __result)
        throws InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __redirectWhisperGroup_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(InvalidSessionException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        IceInternal.BasicStream __is = __result.__is();
        __is.skipEmptyEncaps();
    }

    /**
     * Register a new user.
     * @param info Information about new user. Must include at least "name".
     * @return The ID of the user. See {@link RegisteredUser.userid}.
     **/
    public int
    registerUser(java.util.Map<UserInfo, java.lang.String> info)
        throws InvalidSecretException,
               InvalidUserException,
               ServerBootedException
    {
        return registerUser(info, null, false);
    }

    /**
     * Register a new user.
     * @param info Information about new user. Must include at least "name".
     * @param __ctx The Context map to send with the invocation.
     * @return The ID of the user. See {@link RegisteredUser.userid}.
     **/
    public int
    registerUser(java.util.Map<UserInfo, java.lang.String> info, java.util.Map<String, String> __ctx)
        throws InvalidSecretException,
               InvalidUserException,
               ServerBootedException
    {
        return registerUser(info, __ctx, true);
    }

    private int
    registerUser(java.util.Map<UserInfo, java.lang.String> info, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException,
               InvalidUserException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("registerUser");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                return __del.registerUser(info, __ctx);
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __handleExceptionWrapper(__delBase, __ex);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __registerUser_name = "registerUser";

    /**
     * Register a new user.
     * @param __cb The callback object for the operation.
     * @param info Information about new user. Must include at least "name".
     **/
    public Ice.AsyncResult begin_registerUser(java.util.Map<UserInfo, java.lang.String> info)
    {
        return begin_registerUser(info, null, false, null);
    }

    /**
     * Register a new user.
     * @param __cb The callback object for the operation.
     * @param info Information about new user. Must include at least "name".
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_registerUser(java.util.Map<UserInfo, java.lang.String> info, java.util.Map<String, String> __ctx)
    {
        return begin_registerUser(info, __ctx, true, null);
    }

    /**
     * Register a new user.
     * @param __cb The callback object for the operation.
     * @param info Information about new user. Must include at least "name".
     **/
    public Ice.AsyncResult begin_registerUser(java.util.Map<UserInfo, java.lang.String> info, Ice.Callback __cb)
    {
        return begin_registerUser(info, null, false, __cb);
    }

    /**
     * Register a new user.
     * @param __cb The callback object for the operation.
     * @param info Information about new user. Must include at least "name".
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_registerUser(java.util.Map<UserInfo, java.lang.String> info, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_registerUser(info, __ctx, true, __cb);
    }

    /**
     * Register a new user.
     * @param __cb The callback object for the operation.
     * @param info Information about new user. Must include at least "name".
     **/
    public Ice.AsyncResult begin_registerUser(java.util.Map<UserInfo, java.lang.String> info, Callback_Server_registerUser __cb)
    {
        return begin_registerUser(info, null, false, __cb);
    }

    /**
     * Register a new user.
     * @param __cb The callback object for the operation.
     * @param info Information about new user. Must include at least "name".
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_registerUser(java.util.Map<UserInfo, java.lang.String> info, java.util.Map<String, String> __ctx, Callback_Server_registerUser __cb)
    {
        return begin_registerUser(info, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_registerUser(java.util.Map<UserInfo, java.lang.String> info, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__registerUser_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __registerUser_name, __cb);
        try
        {
            __result.__prepare(__registerUser_name, Ice.OperationMode.Normal, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            UserInfoMapHelper.write(__os, info);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param __ret (return value) The ID of the user. See {@link RegisteredUser.userid}.
     **/
    public int end_registerUser(Ice.AsyncResult __result)
        throws InvalidSecretException,
               InvalidUserException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __registerUser_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(InvalidUserException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        int __ret;
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        __ret = __is.readInt();
        __is.endReadEncaps();
        return __ret;
    }

    /**
     * Remove a callback.
     * 
     * @param cb Callback interface to be removed.
     * @see addCallback
     **/
    public void
    removeCallback(ServerCallbackPrx cb)
        throws InvalidCallbackException,
               InvalidSecretException,
               ServerBootedException
    {
        removeCallback(cb, null, false);
    }

    /**
     * Remove a callback.
     * 
     * @param cb Callback interface to be removed.
     * @see addCallback
     * @param __ctx The Context map to send with the invocation.
     **/
    public void
    removeCallback(ServerCallbackPrx cb, java.util.Map<String, String> __ctx)
        throws InvalidCallbackException,
               InvalidSecretException,
               ServerBootedException
    {
        removeCallback(cb, __ctx, true);
    }

    private void
    removeCallback(ServerCallbackPrx cb, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidCallbackException,
               InvalidSecretException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("removeCallback");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                __del.removeCallback(cb, __ctx);
                return;
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __handleExceptionWrapper(__delBase, __ex);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __removeCallback_name = "removeCallback";

    /**
     * Remove a callback.
     * 
     * @param __cb The callback object for the operation.
     * @param cb Callback interface to be removed.
     **/
    public Ice.AsyncResult begin_removeCallback(ServerCallbackPrx cb)
    {
        return begin_removeCallback(cb, null, false, null);
    }

    /**
     * Remove a callback.
     * 
     * @param __cb The callback object for the operation.
     * @param cb Callback interface to be removed.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_removeCallback(ServerCallbackPrx cb, java.util.Map<String, String> __ctx)
    {
        return begin_removeCallback(cb, __ctx, true, null);
    }

    /**
     * Remove a callback.
     * 
     * @param __cb The callback object for the operation.
     * @param cb Callback interface to be removed.
     **/
    public Ice.AsyncResult begin_removeCallback(ServerCallbackPrx cb, Ice.Callback __cb)
    {
        return begin_removeCallback(cb, null, false, __cb);
    }

    /**
     * Remove a callback.
     * 
     * @param __cb The callback object for the operation.
     * @param cb Callback interface to be removed.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_removeCallback(ServerCallbackPrx cb, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_removeCallback(cb, __ctx, true, __cb);
    }

    /**
     * Remove a callback.
     * 
     * @param __cb The callback object for the operation.
     * @param cb Callback interface to be removed.
     **/
    public Ice.AsyncResult begin_removeCallback(ServerCallbackPrx cb, Callback_Server_removeCallback __cb)
    {
        return begin_removeCallback(cb, null, false, __cb);
    }

    /**
     * Remove a callback.
     * 
     * @param __cb The callback object for the operation.
     * @param cb Callback interface to be removed.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_removeCallback(ServerCallbackPrx cb, java.util.Map<String, String> __ctx, Callback_Server_removeCallback __cb)
    {
        return begin_removeCallback(cb, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_removeCallback(ServerCallbackPrx cb, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__removeCallback_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __removeCallback_name, __cb);
        try
        {
            __result.__prepare(__removeCallback_name, Ice.OperationMode.Normal, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            ServerCallbackPrxHelper.__write(__os, cb);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     **/
    public void end_removeCallback(Ice.AsyncResult __result)
        throws InvalidCallbackException,
               InvalidSecretException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __removeCallback_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidCallbackException __ex)
            {
                throw __ex;
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        IceInternal.BasicStream __is = __result.__is();
        __is.skipEmptyEncaps();
    }

    /**
     * Remove a channel and all its subchannels.
     * @param channelid ID of Channel. See {@link Channel.id}.
     **/
    public void
    removeChannel(int channelid)
        throws InvalidChannelException,
               InvalidSecretException,
               ServerBootedException
    {
        removeChannel(channelid, null, false);
    }

    /**
     * Remove a channel and all its subchannels.
     * @param channelid ID of Channel. See {@link Channel.id}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public void
    removeChannel(int channelid, java.util.Map<String, String> __ctx)
        throws InvalidChannelException,
               InvalidSecretException,
               ServerBootedException
    {
        removeChannel(channelid, __ctx, true);
    }

    private void
    removeChannel(int channelid, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidChannelException,
               InvalidSecretException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("removeChannel");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                __del.removeChannel(channelid, __ctx);
                return;
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __handleExceptionWrapper(__delBase, __ex);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __removeChannel_name = "removeChannel";

    /**
     * Remove a channel and all its subchannels.
     * @param __cb The callback object for the operation.
     * @param channelid ID of Channel. See {@link Channel.id}.
     **/
    public Ice.AsyncResult begin_removeChannel(int channelid)
    {
        return begin_removeChannel(channelid, null, false, null);
    }

    /**
     * Remove a channel and all its subchannels.
     * @param __cb The callback object for the operation.
     * @param channelid ID of Channel. See {@link Channel.id}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_removeChannel(int channelid, java.util.Map<String, String> __ctx)
    {
        return begin_removeChannel(channelid, __ctx, true, null);
    }

    /**
     * Remove a channel and all its subchannels.
     * @param __cb The callback object for the operation.
     * @param channelid ID of Channel. See {@link Channel.id}.
     **/
    public Ice.AsyncResult begin_removeChannel(int channelid, Ice.Callback __cb)
    {
        return begin_removeChannel(channelid, null, false, __cb);
    }

    /**
     * Remove a channel and all its subchannels.
     * @param __cb The callback object for the operation.
     * @param channelid ID of Channel. See {@link Channel.id}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_removeChannel(int channelid, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_removeChannel(channelid, __ctx, true, __cb);
    }

    /**
     * Remove a channel and all its subchannels.
     * @param __cb The callback object for the operation.
     * @param channelid ID of Channel. See {@link Channel.id}.
     **/
    public Ice.AsyncResult begin_removeChannel(int channelid, Callback_Server_removeChannel __cb)
    {
        return begin_removeChannel(channelid, null, false, __cb);
    }

    /**
     * Remove a channel and all its subchannels.
     * @param __cb The callback object for the operation.
     * @param channelid ID of Channel. See {@link Channel.id}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_removeChannel(int channelid, java.util.Map<String, String> __ctx, Callback_Server_removeChannel __cb)
    {
        return begin_removeChannel(channelid, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_removeChannel(int channelid, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__removeChannel_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __removeChannel_name, __cb);
        try
        {
            __result.__prepare(__removeChannel_name, Ice.OperationMode.Normal, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.writeInt(channelid);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     **/
    public void end_removeChannel(Ice.AsyncResult __result)
        throws InvalidChannelException,
               InvalidSecretException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __removeChannel_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidChannelException __ex)
            {
                throw __ex;
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        IceInternal.BasicStream __is = __result.__is();
        __is.skipEmptyEncaps();
    }

    /**
     * Remove a callback.
     * 
     * @param cb Callback interface to be removed. This callback will be removed from all from all users.
     * @see addContextCallback
     **/
    public void
    removeContextCallback(ServerContextCallbackPrx cb)
        throws InvalidCallbackException,
               InvalidSecretException,
               ServerBootedException
    {
        removeContextCallback(cb, null, false);
    }

    /**
     * Remove a callback.
     * 
     * @param cb Callback interface to be removed. This callback will be removed from all from all users.
     * @see addContextCallback
     * @param __ctx The Context map to send with the invocation.
     **/
    public void
    removeContextCallback(ServerContextCallbackPrx cb, java.util.Map<String, String> __ctx)
        throws InvalidCallbackException,
               InvalidSecretException,
               ServerBootedException
    {
        removeContextCallback(cb, __ctx, true);
    }

    private void
    removeContextCallback(ServerContextCallbackPrx cb, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidCallbackException,
               InvalidSecretException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("removeContextCallback");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                __del.removeContextCallback(cb, __ctx);
                return;
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __handleExceptionWrapper(__delBase, __ex);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __removeContextCallback_name = "removeContextCallback";

    /**
     * Remove a callback.
     * 
     * @param __cb The callback object for the operation.
     * @param cb Callback interface to be removed. This callback will be removed from all from all users.
     **/
    public Ice.AsyncResult begin_removeContextCallback(ServerContextCallbackPrx cb)
    {
        return begin_removeContextCallback(cb, null, false, null);
    }

    /**
     * Remove a callback.
     * 
     * @param __cb The callback object for the operation.
     * @param cb Callback interface to be removed. This callback will be removed from all from all users.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_removeContextCallback(ServerContextCallbackPrx cb, java.util.Map<String, String> __ctx)
    {
        return begin_removeContextCallback(cb, __ctx, true, null);
    }

    /**
     * Remove a callback.
     * 
     * @param __cb The callback object for the operation.
     * @param cb Callback interface to be removed. This callback will be removed from all from all users.
     **/
    public Ice.AsyncResult begin_removeContextCallback(ServerContextCallbackPrx cb, Ice.Callback __cb)
    {
        return begin_removeContextCallback(cb, null, false, __cb);
    }

    /**
     * Remove a callback.
     * 
     * @param __cb The callback object for the operation.
     * @param cb Callback interface to be removed. This callback will be removed from all from all users.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_removeContextCallback(ServerContextCallbackPrx cb, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_removeContextCallback(cb, __ctx, true, __cb);
    }

    /**
     * Remove a callback.
     * 
     * @param __cb The callback object for the operation.
     * @param cb Callback interface to be removed. This callback will be removed from all from all users.
     **/
    public Ice.AsyncResult begin_removeContextCallback(ServerContextCallbackPrx cb, Callback_Server_removeContextCallback __cb)
    {
        return begin_removeContextCallback(cb, null, false, __cb);
    }

    /**
     * Remove a callback.
     * 
     * @param __cb The callback object for the operation.
     * @param cb Callback interface to be removed. This callback will be removed from all from all users.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_removeContextCallback(ServerContextCallbackPrx cb, java.util.Map<String, String> __ctx, Callback_Server_removeContextCallback __cb)
    {
        return begin_removeContextCallback(cb, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_removeContextCallback(ServerContextCallbackPrx cb, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__removeContextCallback_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __removeContextCallback_name, __cb);
        try
        {
            __result.__prepare(__removeContextCallback_name, Ice.OperationMode.Normal, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            ServerContextCallbackPrxHelper.__write(__os, cb);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     **/
    public void end_removeContextCallback(Ice.AsyncResult __result)
        throws InvalidCallbackException,
               InvalidSecretException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __removeContextCallback_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidCallbackException __ex)
            {
                throw __ex;
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        IceInternal.BasicStream __is = __result.__is();
        __is.skipEmptyEncaps();
    }

    /**
     * Remove a user from a temporary group membership on a channel. This state is not saved, and is intended for temporary memberships.
     * @param channelid Channel ID of channel to add to. See {@link Channel.id}.
     * @param session Connection ID of user. See {@link User.session}.
     * @param group Group name to remove from.
     **/
    public void
    removeUserFromGroup(int channelid, int session, String group)
        throws InvalidChannelException,
               InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        removeUserFromGroup(channelid, session, group, null, false);
    }

    /**
     * Remove a user from a temporary group membership on a channel. This state is not saved, and is intended for temporary memberships.
     * @param channelid Channel ID of channel to add to. See {@link Channel.id}.
     * @param session Connection ID of user. See {@link User.session}.
     * @param group Group name to remove from.
     * @param __ctx The Context map to send with the invocation.
     **/
    public void
    removeUserFromGroup(int channelid, int session, String group, java.util.Map<String, String> __ctx)
        throws InvalidChannelException,
               InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        removeUserFromGroup(channelid, session, group, __ctx, true);
    }

    private void
    removeUserFromGroup(int channelid, int session, String group, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidChannelException,
               InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("removeUserFromGroup");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                __del.removeUserFromGroup(channelid, session, group, __ctx);
                return;
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __removeUserFromGroup_name = "removeUserFromGroup";

    /**
     * Remove a user from a temporary group membership on a channel. This state is not saved, and is intended for temporary memberships.
     * @param __cb The callback object for the operation.
     * @param channelid Channel ID of channel to add to. See {@link Channel.id}.
     * @param group Group name to remove from.
     **/
    public Ice.AsyncResult begin_removeUserFromGroup(int channelid, int session, String group)
    {
        return begin_removeUserFromGroup(channelid, session, group, null, false, null);
    }

    /**
     * Remove a user from a temporary group membership on a channel. This state is not saved, and is intended for temporary memberships.
     * @param __cb The callback object for the operation.
     * @param channelid Channel ID of channel to add to. See {@link Channel.id}.
     * @param group Group name to remove from.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_removeUserFromGroup(int channelid, int session, String group, java.util.Map<String, String> __ctx)
    {
        return begin_removeUserFromGroup(channelid, session, group, __ctx, true, null);
    }

    /**
     * Remove a user from a temporary group membership on a channel. This state is not saved, and is intended for temporary memberships.
     * @param __cb The callback object for the operation.
     * @param channelid Channel ID of channel to add to. See {@link Channel.id}.
     * @param group Group name to remove from.
     **/
    public Ice.AsyncResult begin_removeUserFromGroup(int channelid, int session, String group, Ice.Callback __cb)
    {
        return begin_removeUserFromGroup(channelid, session, group, null, false, __cb);
    }

    /**
     * Remove a user from a temporary group membership on a channel. This state is not saved, and is intended for temporary memberships.
     * @param __cb The callback object for the operation.
     * @param channelid Channel ID of channel to add to. See {@link Channel.id}.
     * @param group Group name to remove from.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_removeUserFromGroup(int channelid, int session, String group, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_removeUserFromGroup(channelid, session, group, __ctx, true, __cb);
    }

    /**
     * Remove a user from a temporary group membership on a channel. This state is not saved, and is intended for temporary memberships.
     * @param __cb The callback object for the operation.
     * @param channelid Channel ID of channel to add to. See {@link Channel.id}.
     * @param group Group name to remove from.
     **/
    public Ice.AsyncResult begin_removeUserFromGroup(int channelid, int session, String group, Callback_Server_removeUserFromGroup __cb)
    {
        return begin_removeUserFromGroup(channelid, session, group, null, false, __cb);
    }

    /**
     * Remove a user from a temporary group membership on a channel. This state is not saved, and is intended for temporary memberships.
     * @param __cb The callback object for the operation.
     * @param channelid Channel ID of channel to add to. See {@link Channel.id}.
     * @param group Group name to remove from.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_removeUserFromGroup(int channelid, int session, String group, java.util.Map<String, String> __ctx, Callback_Server_removeUserFromGroup __cb)
    {
        return begin_removeUserFromGroup(channelid, session, group, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_removeUserFromGroup(int channelid, int session, String group, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__removeUserFromGroup_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __removeUserFromGroup_name, __cb);
        try
        {
            __result.__prepare(__removeUserFromGroup_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.writeInt(channelid);
            __os.writeInt(session);
            __os.writeString(group);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     **/
    public void end_removeUserFromGroup(Ice.AsyncResult __result)
        throws InvalidChannelException,
               InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __removeUserFromGroup_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidChannelException __ex)
            {
                throw __ex;
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(InvalidSessionException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        IceInternal.BasicStream __is = __result.__is();
        __is.skipEmptyEncaps();
    }

    /**
     * Send text message to a single user.
     * @param session Connection ID of user. See {@link User.session}.
     * @param text Message to send.
     * @see sendMessageChannel
     **/
    public void
    sendMessage(int session, String text)
        throws InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        sendMessage(session, text, null, false);
    }

    /**
     * Send text message to a single user.
     * @param session Connection ID of user. See {@link User.session}.
     * @param text Message to send.
     * @see sendMessageChannel
     * @param __ctx The Context map to send with the invocation.
     **/
    public void
    sendMessage(int session, String text, java.util.Map<String, String> __ctx)
        throws InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        sendMessage(session, text, __ctx, true);
    }

    private void
    sendMessage(int session, String text, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("sendMessage");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                __del.sendMessage(session, text, __ctx);
                return;
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __handleExceptionWrapper(__delBase, __ex);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __sendMessage_name = "sendMessage";

    /**
     * Send text message to a single user.
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     **/
    public Ice.AsyncResult begin_sendMessage(int session, String text)
    {
        return begin_sendMessage(session, text, null, false, null);
    }

    /**
     * Send text message to a single user.
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_sendMessage(int session, String text, java.util.Map<String, String> __ctx)
    {
        return begin_sendMessage(session, text, __ctx, true, null);
    }

    /**
     * Send text message to a single user.
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     **/
    public Ice.AsyncResult begin_sendMessage(int session, String text, Ice.Callback __cb)
    {
        return begin_sendMessage(session, text, null, false, __cb);
    }

    /**
     * Send text message to a single user.
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_sendMessage(int session, String text, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_sendMessage(session, text, __ctx, true, __cb);
    }

    /**
     * Send text message to a single user.
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     **/
    public Ice.AsyncResult begin_sendMessage(int session, String text, Callback_Server_sendMessage __cb)
    {
        return begin_sendMessage(session, text, null, false, __cb);
    }

    /**
     * Send text message to a single user.
     * @param __cb The callback object for the operation.
     * @param session Connection ID of user. See {@link User.session}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_sendMessage(int session, String text, java.util.Map<String, String> __ctx, Callback_Server_sendMessage __cb)
    {
        return begin_sendMessage(session, text, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_sendMessage(int session, String text, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__sendMessage_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __sendMessage_name, __cb);
        try
        {
            __result.__prepare(__sendMessage_name, Ice.OperationMode.Normal, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.writeInt(session);
            __os.writeString(text);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     **/
    public void end_sendMessage(Ice.AsyncResult __result)
        throws InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __sendMessage_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(InvalidSessionException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        IceInternal.BasicStream __is = __result.__is();
        __is.skipEmptyEncaps();
    }

    /**
     * Send text message to channel or a tree of channels.
     * @param channelid Channel ID of channel to send to. See {@link Channel.id}.
     * @param tree If true, the message will be sent to the channel and all its subchannels.
     * @param text Message to send.
     * @see sendMessage
     **/
    public void
    sendMessageChannel(int channelid, boolean tree, String text)
        throws InvalidChannelException,
               InvalidSecretException,
               ServerBootedException
    {
        sendMessageChannel(channelid, tree, text, null, false);
    }

    /**
     * Send text message to channel or a tree of channels.
     * @param channelid Channel ID of channel to send to. See {@link Channel.id}.
     * @param tree If true, the message will be sent to the channel and all its subchannels.
     * @param text Message to send.
     * @see sendMessage
     * @param __ctx The Context map to send with the invocation.
     **/
    public void
    sendMessageChannel(int channelid, boolean tree, String text, java.util.Map<String, String> __ctx)
        throws InvalidChannelException,
               InvalidSecretException,
               ServerBootedException
    {
        sendMessageChannel(channelid, tree, text, __ctx, true);
    }

    private void
    sendMessageChannel(int channelid, boolean tree, String text, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidChannelException,
               InvalidSecretException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("sendMessageChannel");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                __del.sendMessageChannel(channelid, tree, text, __ctx);
                return;
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __handleExceptionWrapper(__delBase, __ex);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __sendMessageChannel_name = "sendMessageChannel";

    /**
     * Send text message to channel or a tree of channels.
     * @param __cb The callback object for the operation.
     * @param channelid Channel ID of channel to send to. See {@link Channel.id}.
     * @param text Message to send.
     **/
    public Ice.AsyncResult begin_sendMessageChannel(int channelid, boolean tree, String text)
    {
        return begin_sendMessageChannel(channelid, tree, text, null, false, null);
    }

    /**
     * Send text message to channel or a tree of channels.
     * @param __cb The callback object for the operation.
     * @param channelid Channel ID of channel to send to. See {@link Channel.id}.
     * @param text Message to send.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_sendMessageChannel(int channelid, boolean tree, String text, java.util.Map<String, String> __ctx)
    {
        return begin_sendMessageChannel(channelid, tree, text, __ctx, true, null);
    }

    /**
     * Send text message to channel or a tree of channels.
     * @param __cb The callback object for the operation.
     * @param channelid Channel ID of channel to send to. See {@link Channel.id}.
     * @param text Message to send.
     **/
    public Ice.AsyncResult begin_sendMessageChannel(int channelid, boolean tree, String text, Ice.Callback __cb)
    {
        return begin_sendMessageChannel(channelid, tree, text, null, false, __cb);
    }

    /**
     * Send text message to channel or a tree of channels.
     * @param __cb The callback object for the operation.
     * @param channelid Channel ID of channel to send to. See {@link Channel.id}.
     * @param text Message to send.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_sendMessageChannel(int channelid, boolean tree, String text, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_sendMessageChannel(channelid, tree, text, __ctx, true, __cb);
    }

    /**
     * Send text message to channel or a tree of channels.
     * @param __cb The callback object for the operation.
     * @param channelid Channel ID of channel to send to. See {@link Channel.id}.
     * @param text Message to send.
     **/
    public Ice.AsyncResult begin_sendMessageChannel(int channelid, boolean tree, String text, Callback_Server_sendMessageChannel __cb)
    {
        return begin_sendMessageChannel(channelid, tree, text, null, false, __cb);
    }

    /**
     * Send text message to channel or a tree of channels.
     * @param __cb The callback object for the operation.
     * @param channelid Channel ID of channel to send to. See {@link Channel.id}.
     * @param text Message to send.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_sendMessageChannel(int channelid, boolean tree, String text, java.util.Map<String, String> __ctx, Callback_Server_sendMessageChannel __cb)
    {
        return begin_sendMessageChannel(channelid, tree, text, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_sendMessageChannel(int channelid, boolean tree, String text, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__sendMessageChannel_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __sendMessageChannel_name, __cb);
        try
        {
            __result.__prepare(__sendMessageChannel_name, Ice.OperationMode.Normal, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.writeInt(channelid);
            __os.writeBool(tree);
            __os.writeString(text);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     **/
    public void end_sendMessageChannel(Ice.AsyncResult __result)
        throws InvalidChannelException,
               InvalidSecretException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __sendMessageChannel_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidChannelException __ex)
            {
                throw __ex;
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        IceInternal.BasicStream __is = __result.__is();
        __is.skipEmptyEncaps();
    }

    /**
     * Set ACLs and Groups on a channel. Note that this will replace all existing ACLs and groups on the channel.
     * @param channelid Channel ID of channel to fetch from. See {@link Channel.id}.
     * @param acls List of ACLs on the channel.
     * @param groups List of groups on the channel.
     * @param inherit Should this channel inherit ACLs from the parent channel?
     **/
    public void
    setACL(int channelid, ACL[] acls, Group[] groups, boolean inherit)
        throws InvalidChannelException,
               InvalidSecretException,
               ServerBootedException
    {
        setACL(channelid, acls, groups, inherit, null, false);
    }

    /**
     * Set ACLs and Groups on a channel. Note that this will replace all existing ACLs and groups on the channel.
     * @param channelid Channel ID of channel to fetch from. See {@link Channel.id}.
     * @param acls List of ACLs on the channel.
     * @param groups List of groups on the channel.
     * @param inherit Should this channel inherit ACLs from the parent channel?
     * @param __ctx The Context map to send with the invocation.
     **/
    public void
    setACL(int channelid, ACL[] acls, Group[] groups, boolean inherit, java.util.Map<String, String> __ctx)
        throws InvalidChannelException,
               InvalidSecretException,
               ServerBootedException
    {
        setACL(channelid, acls, groups, inherit, __ctx, true);
    }

    private void
    setACL(int channelid, ACL[] acls, Group[] groups, boolean inherit, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidChannelException,
               InvalidSecretException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("setACL");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                __del.setACL(channelid, acls, groups, inherit, __ctx);
                return;
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __setACL_name = "setACL";

    /**
     * Set ACLs and Groups on a channel. Note that this will replace all existing ACLs and groups on the channel.
     * @param __cb The callback object for the operation.
     * @param channelid Channel ID of channel to fetch from. See {@link Channel.id}.
     * @param groups List of groups on the channel.
     **/
    public Ice.AsyncResult begin_setACL(int channelid, ACL[] acls, Group[] groups, boolean inherit)
    {
        return begin_setACL(channelid, acls, groups, inherit, null, false, null);
    }

    /**
     * Set ACLs and Groups on a channel. Note that this will replace all existing ACLs and groups on the channel.
     * @param __cb The callback object for the operation.
     * @param channelid Channel ID of channel to fetch from. See {@link Channel.id}.
     * @param groups List of groups on the channel.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_setACL(int channelid, ACL[] acls, Group[] groups, boolean inherit, java.util.Map<String, String> __ctx)
    {
        return begin_setACL(channelid, acls, groups, inherit, __ctx, true, null);
    }

    /**
     * Set ACLs and Groups on a channel. Note that this will replace all existing ACLs and groups on the channel.
     * @param __cb The callback object for the operation.
     * @param channelid Channel ID of channel to fetch from. See {@link Channel.id}.
     * @param groups List of groups on the channel.
     **/
    public Ice.AsyncResult begin_setACL(int channelid, ACL[] acls, Group[] groups, boolean inherit, Ice.Callback __cb)
    {
        return begin_setACL(channelid, acls, groups, inherit, null, false, __cb);
    }

    /**
     * Set ACLs and Groups on a channel. Note that this will replace all existing ACLs and groups on the channel.
     * @param __cb The callback object for the operation.
     * @param channelid Channel ID of channel to fetch from. See {@link Channel.id}.
     * @param groups List of groups on the channel.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_setACL(int channelid, ACL[] acls, Group[] groups, boolean inherit, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_setACL(channelid, acls, groups, inherit, __ctx, true, __cb);
    }

    /**
     * Set ACLs and Groups on a channel. Note that this will replace all existing ACLs and groups on the channel.
     * @param __cb The callback object for the operation.
     * @param channelid Channel ID of channel to fetch from. See {@link Channel.id}.
     * @param groups List of groups on the channel.
     **/
    public Ice.AsyncResult begin_setACL(int channelid, ACL[] acls, Group[] groups, boolean inherit, Callback_Server_setACL __cb)
    {
        return begin_setACL(channelid, acls, groups, inherit, null, false, __cb);
    }

    /**
     * Set ACLs and Groups on a channel. Note that this will replace all existing ACLs and groups on the channel.
     * @param __cb The callback object for the operation.
     * @param channelid Channel ID of channel to fetch from. See {@link Channel.id}.
     * @param groups List of groups on the channel.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_setACL(int channelid, ACL[] acls, Group[] groups, boolean inherit, java.util.Map<String, String> __ctx, Callback_Server_setACL __cb)
    {
        return begin_setACL(channelid, acls, groups, inherit, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_setACL(int channelid, ACL[] acls, Group[] groups, boolean inherit, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__setACL_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __setACL_name, __cb);
        try
        {
            __result.__prepare(__setACL_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.writeInt(channelid);
            ACLListHelper.write(__os, acls);
            GroupListHelper.write(__os, groups);
            __os.writeBool(inherit);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     **/
    public void end_setACL(Ice.AsyncResult __result)
        throws InvalidChannelException,
               InvalidSecretException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __setACL_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidChannelException __ex)
            {
                throw __ex;
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        IceInternal.BasicStream __is = __result.__is();
        __is.skipEmptyEncaps();
    }

    /**
     * Set external authenticator. If set, all authentications from clients are forwarded to this
     * proxy.
     * 
     * @param auth Authenticator object to perform subsequent authentications.
     **/
    public void
    setAuthenticator(ServerAuthenticatorPrx auth)
        throws InvalidCallbackException,
               InvalidSecretException,
               ServerBootedException
    {
        setAuthenticator(auth, null, false);
    }

    /**
     * Set external authenticator. If set, all authentications from clients are forwarded to this
     * proxy.
     * 
     * @param auth Authenticator object to perform subsequent authentications.
     * @param __ctx The Context map to send with the invocation.
     **/
    public void
    setAuthenticator(ServerAuthenticatorPrx auth, java.util.Map<String, String> __ctx)
        throws InvalidCallbackException,
               InvalidSecretException,
               ServerBootedException
    {
        setAuthenticator(auth, __ctx, true);
    }

    private void
    setAuthenticator(ServerAuthenticatorPrx auth, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidCallbackException,
               InvalidSecretException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("setAuthenticator");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                __del.setAuthenticator(auth, __ctx);
                return;
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __handleExceptionWrapper(__delBase, __ex);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __setAuthenticator_name = "setAuthenticator";

    /**
     * Set external authenticator. If set, all authentications from clients are forwarded to this
     * proxy.
     * 
     * @param __cb The callback object for the operation.
     * @param auth Authenticator object to perform subsequent authentications.
     **/
    public Ice.AsyncResult begin_setAuthenticator(ServerAuthenticatorPrx auth)
    {
        return begin_setAuthenticator(auth, null, false, null);
    }

    /**
     * Set external authenticator. If set, all authentications from clients are forwarded to this
     * proxy.
     * 
     * @param __cb The callback object for the operation.
     * @param auth Authenticator object to perform subsequent authentications.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_setAuthenticator(ServerAuthenticatorPrx auth, java.util.Map<String, String> __ctx)
    {
        return begin_setAuthenticator(auth, __ctx, true, null);
    }

    /**
     * Set external authenticator. If set, all authentications from clients are forwarded to this
     * proxy.
     * 
     * @param __cb The callback object for the operation.
     * @param auth Authenticator object to perform subsequent authentications.
     **/
    public Ice.AsyncResult begin_setAuthenticator(ServerAuthenticatorPrx auth, Ice.Callback __cb)
    {
        return begin_setAuthenticator(auth, null, false, __cb);
    }

    /**
     * Set external authenticator. If set, all authentications from clients are forwarded to this
     * proxy.
     * 
     * @param __cb The callback object for the operation.
     * @param auth Authenticator object to perform subsequent authentications.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_setAuthenticator(ServerAuthenticatorPrx auth, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_setAuthenticator(auth, __ctx, true, __cb);
    }

    /**
     * Set external authenticator. If set, all authentications from clients are forwarded to this
     * proxy.
     * 
     * @param __cb The callback object for the operation.
     * @param auth Authenticator object to perform subsequent authentications.
     **/
    public Ice.AsyncResult begin_setAuthenticator(ServerAuthenticatorPrx auth, Callback_Server_setAuthenticator __cb)
    {
        return begin_setAuthenticator(auth, null, false, __cb);
    }

    /**
     * Set external authenticator. If set, all authentications from clients are forwarded to this
     * proxy.
     * 
     * @param __cb The callback object for the operation.
     * @param auth Authenticator object to perform subsequent authentications.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_setAuthenticator(ServerAuthenticatorPrx auth, java.util.Map<String, String> __ctx, Callback_Server_setAuthenticator __cb)
    {
        return begin_setAuthenticator(auth, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_setAuthenticator(ServerAuthenticatorPrx auth, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__setAuthenticator_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __setAuthenticator_name, __cb);
        try
        {
            __result.__prepare(__setAuthenticator_name, Ice.OperationMode.Normal, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            ServerAuthenticatorPrxHelper.__write(__os, auth);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     **/
    public void end_setAuthenticator(Ice.AsyncResult __result)
        throws InvalidCallbackException,
               InvalidSecretException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __setAuthenticator_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidCallbackException __ex)
            {
                throw __ex;
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        IceInternal.BasicStream __is = __result.__is();
        __is.skipEmptyEncaps();
    }

    /**
     * Set all current IP bans on the server. This will replace any bans already present, so if you want to add a ban, be sure to call {@link getBans} and then
     * append to the returned list before calling this method.
     * @param bans List of bans.
     **/
    public void
    setBans(Ban[] bans)
        throws InvalidSecretException,
               ServerBootedException
    {
        setBans(bans, null, false);
    }

    /**
     * Set all current IP bans on the server. This will replace any bans already present, so if you want to add a ban, be sure to call {@link getBans} and then
     * append to the returned list before calling this method.
     * @param bans List of bans.
     * @param __ctx The Context map to send with the invocation.
     **/
    public void
    setBans(Ban[] bans, java.util.Map<String, String> __ctx)
        throws InvalidSecretException,
               ServerBootedException
    {
        setBans(bans, __ctx, true);
    }

    private void
    setBans(Ban[] bans, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("setBans");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                __del.setBans(bans, __ctx);
                return;
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __setBans_name = "setBans";

    /**
     * Set all current IP bans on the server. This will replace any bans already present, so if you want to add a ban, be sure to call {@link getBans} and then
     * append to the returned list before calling this method.
     * @param __cb The callback object for the operation.
     * @param bans List of bans.
     **/
    public Ice.AsyncResult begin_setBans(Ban[] bans)
    {
        return begin_setBans(bans, null, false, null);
    }

    /**
     * Set all current IP bans on the server. This will replace any bans already present, so if you want to add a ban, be sure to call {@link getBans} and then
     * append to the returned list before calling this method.
     * @param __cb The callback object for the operation.
     * @param bans List of bans.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_setBans(Ban[] bans, java.util.Map<String, String> __ctx)
    {
        return begin_setBans(bans, __ctx, true, null);
    }

    /**
     * Set all current IP bans on the server. This will replace any bans already present, so if you want to add a ban, be sure to call {@link getBans} and then
     * append to the returned list before calling this method.
     * @param __cb The callback object for the operation.
     * @param bans List of bans.
     **/
    public Ice.AsyncResult begin_setBans(Ban[] bans, Ice.Callback __cb)
    {
        return begin_setBans(bans, null, false, __cb);
    }

    /**
     * Set all current IP bans on the server. This will replace any bans already present, so if you want to add a ban, be sure to call {@link getBans} and then
     * append to the returned list before calling this method.
     * @param __cb The callback object for the operation.
     * @param bans List of bans.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_setBans(Ban[] bans, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_setBans(bans, __ctx, true, __cb);
    }

    /**
     * Set all current IP bans on the server. This will replace any bans already present, so if you want to add a ban, be sure to call {@link getBans} and then
     * append to the returned list before calling this method.
     * @param __cb The callback object for the operation.
     * @param bans List of bans.
     **/
    public Ice.AsyncResult begin_setBans(Ban[] bans, Callback_Server_setBans __cb)
    {
        return begin_setBans(bans, null, false, __cb);
    }

    /**
     * Set all current IP bans on the server. This will replace any bans already present, so if you want to add a ban, be sure to call {@link getBans} and then
     * append to the returned list before calling this method.
     * @param __cb The callback object for the operation.
     * @param bans List of bans.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_setBans(Ban[] bans, java.util.Map<String, String> __ctx, Callback_Server_setBans __cb)
    {
        return begin_setBans(bans, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_setBans(Ban[] bans, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__setBans_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __setBans_name, __cb);
        try
        {
            __result.__prepare(__setBans_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            BanListHelper.write(__os, bans);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     **/
    public void end_setBans(Ice.AsyncResult __result)
        throws InvalidSecretException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __setBans_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        IceInternal.BasicStream __is = __result.__is();
        __is.skipEmptyEncaps();
    }

    /**
     * Set state of a single channel. You can use this to move or relink channels.
     * @param state Channel state to set.
     * @see getChannelState
     **/
    public void
    setChannelState(Channel state)
        throws InvalidChannelException,
               InvalidSecretException,
               ServerBootedException
    {
        setChannelState(state, null, false);
    }

    /**
     * Set state of a single channel. You can use this to move or relink channels.
     * @param state Channel state to set.
     * @see getChannelState
     * @param __ctx The Context map to send with the invocation.
     **/
    public void
    setChannelState(Channel state, java.util.Map<String, String> __ctx)
        throws InvalidChannelException,
               InvalidSecretException,
               ServerBootedException
    {
        setChannelState(state, __ctx, true);
    }

    private void
    setChannelState(Channel state, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidChannelException,
               InvalidSecretException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("setChannelState");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                __del.setChannelState(state, __ctx);
                return;
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __setChannelState_name = "setChannelState";

    /**
     * Set state of a single channel. You can use this to move or relink channels.
     * @param __cb The callback object for the operation.
     * @param state Channel state to set.
     **/
    public Ice.AsyncResult begin_setChannelState(Channel state)
    {
        return begin_setChannelState(state, null, false, null);
    }

    /**
     * Set state of a single channel. You can use this to move or relink channels.
     * @param __cb The callback object for the operation.
     * @param state Channel state to set.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_setChannelState(Channel state, java.util.Map<String, String> __ctx)
    {
        return begin_setChannelState(state, __ctx, true, null);
    }

    /**
     * Set state of a single channel. You can use this to move or relink channels.
     * @param __cb The callback object for the operation.
     * @param state Channel state to set.
     **/
    public Ice.AsyncResult begin_setChannelState(Channel state, Ice.Callback __cb)
    {
        return begin_setChannelState(state, null, false, __cb);
    }

    /**
     * Set state of a single channel. You can use this to move or relink channels.
     * @param __cb The callback object for the operation.
     * @param state Channel state to set.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_setChannelState(Channel state, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_setChannelState(state, __ctx, true, __cb);
    }

    /**
     * Set state of a single channel. You can use this to move or relink channels.
     * @param __cb The callback object for the operation.
     * @param state Channel state to set.
     **/
    public Ice.AsyncResult begin_setChannelState(Channel state, Callback_Server_setChannelState __cb)
    {
        return begin_setChannelState(state, null, false, __cb);
    }

    /**
     * Set state of a single channel. You can use this to move or relink channels.
     * @param __cb The callback object for the operation.
     * @param state Channel state to set.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_setChannelState(Channel state, java.util.Map<String, String> __ctx, Callback_Server_setChannelState __cb)
    {
        return begin_setChannelState(state, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_setChannelState(Channel state, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__setChannelState_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __setChannelState_name, __cb);
        try
        {
            __result.__prepare(__setChannelState_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            state.__write(__os);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     **/
    public void end_setChannelState(Ice.AsyncResult __result)
        throws InvalidChannelException,
               InvalidSecretException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __setChannelState_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidChannelException __ex)
            {
                throw __ex;
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        IceInternal.BasicStream __is = __result.__is();
        __is.skipEmptyEncaps();
    }

    /**
     * Set a configuration item.
     * @param key Configuration key.
     * @param value Configuration value.
     **/
    public void
    setConf(String key, String value)
        throws InvalidSecretException
    {
        setConf(key, value, null, false);
    }

    /**
     * Set a configuration item.
     * @param key Configuration key.
     * @param value Configuration value.
     * @param __ctx The Context map to send with the invocation.
     **/
    public void
    setConf(String key, String value, java.util.Map<String, String> __ctx)
        throws InvalidSecretException
    {
        setConf(key, value, __ctx, true);
    }

    private void
    setConf(String key, String value, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("setConf");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                __del.setConf(key, value, __ctx);
                return;
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __setConf_name = "setConf";

    /**
     * Set a configuration item.
     * @param __cb The callback object for the operation.
     * @param key Configuration key.
     **/
    public Ice.AsyncResult begin_setConf(String key, String value)
    {
        return begin_setConf(key, value, null, false, null);
    }

    /**
     * Set a configuration item.
     * @param __cb The callback object for the operation.
     * @param key Configuration key.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_setConf(String key, String value, java.util.Map<String, String> __ctx)
    {
        return begin_setConf(key, value, __ctx, true, null);
    }

    /**
     * Set a configuration item.
     * @param __cb The callback object for the operation.
     * @param key Configuration key.
     **/
    public Ice.AsyncResult begin_setConf(String key, String value, Ice.Callback __cb)
    {
        return begin_setConf(key, value, null, false, __cb);
    }

    /**
     * Set a configuration item.
     * @param __cb The callback object for the operation.
     * @param key Configuration key.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_setConf(String key, String value, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_setConf(key, value, __ctx, true, __cb);
    }

    /**
     * Set a configuration item.
     * @param __cb The callback object for the operation.
     * @param key Configuration key.
     **/
    public Ice.AsyncResult begin_setConf(String key, String value, Callback_Server_setConf __cb)
    {
        return begin_setConf(key, value, null, false, __cb);
    }

    /**
     * Set a configuration item.
     * @param __cb The callback object for the operation.
     * @param key Configuration key.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_setConf(String key, String value, java.util.Map<String, String> __ctx, Callback_Server_setConf __cb)
    {
        return begin_setConf(key, value, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_setConf(String key, String value, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__setConf_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __setConf_name, __cb);
        try
        {
            __result.__prepare(__setConf_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.writeString(key);
            __os.writeString(value);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     **/
    public void end_setConf(Ice.AsyncResult __result)
        throws InvalidSecretException
    {
        Ice.AsyncResult.__check(__result, this, __setConf_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        IceInternal.BasicStream __is = __result.__is();
        __is.skipEmptyEncaps();
    }

    /**
     * Set user state. You can use this to move, mute and deafen users.
     * @param state User state to set.
     * @see getState
     **/
    public void
    setState(User state)
        throws InvalidChannelException,
               InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        setState(state, null, false);
    }

    /**
     * Set user state. You can use this to move, mute and deafen users.
     * @param state User state to set.
     * @see getState
     * @param __ctx The Context map to send with the invocation.
     **/
    public void
    setState(User state, java.util.Map<String, String> __ctx)
        throws InvalidChannelException,
               InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        setState(state, __ctx, true);
    }

    private void
    setState(User state, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidChannelException,
               InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("setState");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                __del.setState(state, __ctx);
                return;
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __setState_name = "setState";

    /**
     * Set user state. You can use this to move, mute and deafen users.
     * @param __cb The callback object for the operation.
     * @param state User state to set.
     **/
    public Ice.AsyncResult begin_setState(User state)
    {
        return begin_setState(state, null, false, null);
    }

    /**
     * Set user state. You can use this to move, mute and deafen users.
     * @param __cb The callback object for the operation.
     * @param state User state to set.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_setState(User state, java.util.Map<String, String> __ctx)
    {
        return begin_setState(state, __ctx, true, null);
    }

    /**
     * Set user state. You can use this to move, mute and deafen users.
     * @param __cb The callback object for the operation.
     * @param state User state to set.
     **/
    public Ice.AsyncResult begin_setState(User state, Ice.Callback __cb)
    {
        return begin_setState(state, null, false, __cb);
    }

    /**
     * Set user state. You can use this to move, mute and deafen users.
     * @param __cb The callback object for the operation.
     * @param state User state to set.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_setState(User state, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_setState(state, __ctx, true, __cb);
    }

    /**
     * Set user state. You can use this to move, mute and deafen users.
     * @param __cb The callback object for the operation.
     * @param state User state to set.
     **/
    public Ice.AsyncResult begin_setState(User state, Callback_Server_setState __cb)
    {
        return begin_setState(state, null, false, __cb);
    }

    /**
     * Set user state. You can use this to move, mute and deafen users.
     * @param __cb The callback object for the operation.
     * @param state User state to set.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_setState(User state, java.util.Map<String, String> __ctx, Callback_Server_setState __cb)
    {
        return begin_setState(state, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_setState(User state, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__setState_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __setState_name, __cb);
        try
        {
            __result.__prepare(__setState_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            state.__write(__os);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     **/
    public void end_setState(Ice.AsyncResult __result)
        throws InvalidChannelException,
               InvalidSecretException,
               InvalidSessionException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __setState_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidChannelException __ex)
            {
                throw __ex;
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(InvalidSessionException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        IceInternal.BasicStream __is = __result.__is();
        __is.skipEmptyEncaps();
    }

    /**
     * Set superuser password. This is just a convenience for using {@link updateRegistration} on user id 0.
     * @param pw Password.
     **/
    public void
    setSuperuserPassword(String pw)
        throws InvalidSecretException
    {
        setSuperuserPassword(pw, null, false);
    }

    /**
     * Set superuser password. This is just a convenience for using {@link updateRegistration} on user id 0.
     * @param pw Password.
     * @param __ctx The Context map to send with the invocation.
     **/
    public void
    setSuperuserPassword(String pw, java.util.Map<String, String> __ctx)
        throws InvalidSecretException
    {
        setSuperuserPassword(pw, __ctx, true);
    }

    private void
    setSuperuserPassword(String pw, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("setSuperuserPassword");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                __del.setSuperuserPassword(pw, __ctx);
                return;
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __setSuperuserPassword_name = "setSuperuserPassword";

    /**
     * Set superuser password. This is just a convenience for using {@link updateRegistration} on user id 0.
     * @param __cb The callback object for the operation.
     * @param pw Password.
     **/
    public Ice.AsyncResult begin_setSuperuserPassword(String pw)
    {
        return begin_setSuperuserPassword(pw, null, false, null);
    }

    /**
     * Set superuser password. This is just a convenience for using {@link updateRegistration} on user id 0.
     * @param __cb The callback object for the operation.
     * @param pw Password.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_setSuperuserPassword(String pw, java.util.Map<String, String> __ctx)
    {
        return begin_setSuperuserPassword(pw, __ctx, true, null);
    }

    /**
     * Set superuser password. This is just a convenience for using {@link updateRegistration} on user id 0.
     * @param __cb The callback object for the operation.
     * @param pw Password.
     **/
    public Ice.AsyncResult begin_setSuperuserPassword(String pw, Ice.Callback __cb)
    {
        return begin_setSuperuserPassword(pw, null, false, __cb);
    }

    /**
     * Set superuser password. This is just a convenience for using {@link updateRegistration} on user id 0.
     * @param __cb The callback object for the operation.
     * @param pw Password.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_setSuperuserPassword(String pw, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_setSuperuserPassword(pw, __ctx, true, __cb);
    }

    /**
     * Set superuser password. This is just a convenience for using {@link updateRegistration} on user id 0.
     * @param __cb The callback object for the operation.
     * @param pw Password.
     **/
    public Ice.AsyncResult begin_setSuperuserPassword(String pw, Callback_Server_setSuperuserPassword __cb)
    {
        return begin_setSuperuserPassword(pw, null, false, __cb);
    }

    /**
     * Set superuser password. This is just a convenience for using {@link updateRegistration} on user id 0.
     * @param __cb The callback object for the operation.
     * @param pw Password.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_setSuperuserPassword(String pw, java.util.Map<String, String> __ctx, Callback_Server_setSuperuserPassword __cb)
    {
        return begin_setSuperuserPassword(pw, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_setSuperuserPassword(String pw, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__setSuperuserPassword_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __setSuperuserPassword_name, __cb);
        try
        {
            __result.__prepare(__setSuperuserPassword_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.writeString(pw);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     **/
    public void end_setSuperuserPassword(Ice.AsyncResult __result)
        throws InvalidSecretException
    {
        Ice.AsyncResult.__check(__result, this, __setSuperuserPassword_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        IceInternal.BasicStream __is = __result.__is();
        __is.skipEmptyEncaps();
    }

    /**
     * Set a user texture (now called avatar).
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     * @param tex Texture (as a Byte-Array) to set for the user, or an empty texture to remove the existing texture.
     **/
    public void
    setTexture(int userid, byte[] tex)
        throws InvalidSecretException,
               InvalidTextureException,
               InvalidUserException,
               ServerBootedException
    {
        setTexture(userid, tex, null, false);
    }

    /**
     * Set a user texture (now called avatar).
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     * @param tex Texture (as a Byte-Array) to set for the user, or an empty texture to remove the existing texture.
     * @param __ctx The Context map to send with the invocation.
     **/
    public void
    setTexture(int userid, byte[] tex, java.util.Map<String, String> __ctx)
        throws InvalidSecretException,
               InvalidTextureException,
               InvalidUserException,
               ServerBootedException
    {
        setTexture(userid, tex, __ctx, true);
    }

    private void
    setTexture(int userid, byte[] tex, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException,
               InvalidTextureException,
               InvalidUserException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("setTexture");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                __del.setTexture(userid, tex, __ctx);
                return;
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __setTexture_name = "setTexture";

    /**
     * Set a user texture (now called avatar).
     * @param __cb The callback object for the operation.
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     **/
    public Ice.AsyncResult begin_setTexture(int userid, byte[] tex)
    {
        return begin_setTexture(userid, tex, null, false, null);
    }

    /**
     * Set a user texture (now called avatar).
     * @param __cb The callback object for the operation.
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_setTexture(int userid, byte[] tex, java.util.Map<String, String> __ctx)
    {
        return begin_setTexture(userid, tex, __ctx, true, null);
    }

    /**
     * Set a user texture (now called avatar).
     * @param __cb The callback object for the operation.
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     **/
    public Ice.AsyncResult begin_setTexture(int userid, byte[] tex, Ice.Callback __cb)
    {
        return begin_setTexture(userid, tex, null, false, __cb);
    }

    /**
     * Set a user texture (now called avatar).
     * @param __cb The callback object for the operation.
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_setTexture(int userid, byte[] tex, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_setTexture(userid, tex, __ctx, true, __cb);
    }

    /**
     * Set a user texture (now called avatar).
     * @param __cb The callback object for the operation.
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     **/
    public Ice.AsyncResult begin_setTexture(int userid, byte[] tex, Callback_Server_setTexture __cb)
    {
        return begin_setTexture(userid, tex, null, false, __cb);
    }

    /**
     * Set a user texture (now called avatar).
     * @param __cb The callback object for the operation.
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_setTexture(int userid, byte[] tex, java.util.Map<String, String> __ctx, Callback_Server_setTexture __cb)
    {
        return begin_setTexture(userid, tex, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_setTexture(int userid, byte[] tex, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__setTexture_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __setTexture_name, __cb);
        try
        {
            __result.__prepare(__setTexture_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.writeInt(userid);
            TextureHelper.write(__os, tex);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     **/
    public void end_setTexture(Ice.AsyncResult __result)
        throws InvalidSecretException,
               InvalidTextureException,
               InvalidUserException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __setTexture_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(InvalidTextureException __ex)
            {
                throw __ex;
            }
            catch(InvalidUserException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        IceInternal.BasicStream __is = __result.__is();
        __is.skipEmptyEncaps();
    }

    /**
     * Start server.
     **/
    public void
    start()
        throws InvalidSecretException,
               ServerBootedException,
               ServerFailureException
    {
        start(null, false);
    }

    /**
     * Start server.
     * @param __ctx The Context map to send with the invocation.
     **/
    public void
    start(java.util.Map<String, String> __ctx)
        throws InvalidSecretException,
               ServerBootedException,
               ServerFailureException
    {
        start(__ctx, true);
    }

    private void
    start(java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException,
               ServerBootedException,
               ServerFailureException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("start");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                __del.start(__ctx);
                return;
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __handleExceptionWrapper(__delBase, __ex);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __start_name = "start";

    /**
     * Start server.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_start()
    {
        return begin_start(null, false, null);
    }

    /**
     * Start server.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_start(java.util.Map<String, String> __ctx)
    {
        return begin_start(__ctx, true, null);
    }

    /**
     * Start server.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_start(Ice.Callback __cb)
    {
        return begin_start(null, false, __cb);
    }

    /**
     * Start server.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_start(java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_start(__ctx, true, __cb);
    }

    /**
     * Start server.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_start(Callback_Server_start __cb)
    {
        return begin_start(null, false, __cb);
    }

    /**
     * Start server.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_start(java.util.Map<String, String> __ctx, Callback_Server_start __cb)
    {
        return begin_start(__ctx, true, __cb);
    }

    private Ice.AsyncResult begin_start(java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__start_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __start_name, __cb);
        try
        {
            __result.__prepare(__start_name, Ice.OperationMode.Normal, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     **/
    public void end_start(Ice.AsyncResult __result)
        throws InvalidSecretException,
               ServerBootedException,
               ServerFailureException
    {
        Ice.AsyncResult.__check(__result, this, __start_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(ServerFailureException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        IceInternal.BasicStream __is = __result.__is();
        __is.skipEmptyEncaps();
    }

    /**
     * Stop server.
     **/
    public void
    stop()
        throws InvalidSecretException,
               ServerBootedException
    {
        stop(null, false);
    }

    /**
     * Stop server.
     * @param __ctx The Context map to send with the invocation.
     **/
    public void
    stop(java.util.Map<String, String> __ctx)
        throws InvalidSecretException,
               ServerBootedException
    {
        stop(__ctx, true);
    }

    private void
    stop(java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("stop");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                __del.stop(__ctx);
                return;
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __handleExceptionWrapper(__delBase, __ex);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __stop_name = "stop";

    /**
     * Stop server.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_stop()
    {
        return begin_stop(null, false, null);
    }

    /**
     * Stop server.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_stop(java.util.Map<String, String> __ctx)
    {
        return begin_stop(__ctx, true, null);
    }

    /**
     * Stop server.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_stop(Ice.Callback __cb)
    {
        return begin_stop(null, false, __cb);
    }

    /**
     * Stop server.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_stop(java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_stop(__ctx, true, __cb);
    }

    /**
     * Stop server.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_stop(Callback_Server_stop __cb)
    {
        return begin_stop(null, false, __cb);
    }

    /**
     * Stop server.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_stop(java.util.Map<String, String> __ctx, Callback_Server_stop __cb)
    {
        return begin_stop(__ctx, true, __cb);
    }

    private Ice.AsyncResult begin_stop(java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__stop_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __stop_name, __cb);
        try
        {
            __result.__prepare(__stop_name, Ice.OperationMode.Normal, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     **/
    public void end_stop(Ice.AsyncResult __result)
        throws InvalidSecretException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __stop_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        IceInternal.BasicStream __is = __result.__is();
        __is.skipEmptyEncaps();
    }

    /**
     * Remove a user registration.
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     **/
    public void
    unregisterUser(int userid)
        throws InvalidSecretException,
               InvalidUserException,
               ServerBootedException
    {
        unregisterUser(userid, null, false);
    }

    /**
     * Remove a user registration.
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public void
    unregisterUser(int userid, java.util.Map<String, String> __ctx)
        throws InvalidSecretException,
               InvalidUserException,
               ServerBootedException
    {
        unregisterUser(userid, __ctx, true);
    }

    private void
    unregisterUser(int userid, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException,
               InvalidUserException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("unregisterUser");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                __del.unregisterUser(userid, __ctx);
                return;
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __handleExceptionWrapper(__delBase, __ex);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __unregisterUser_name = "unregisterUser";

    /**
     * Remove a user registration.
     * @param __cb The callback object for the operation.
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     **/
    public Ice.AsyncResult begin_unregisterUser(int userid)
    {
        return begin_unregisterUser(userid, null, false, null);
    }

    /**
     * Remove a user registration.
     * @param __cb The callback object for the operation.
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_unregisterUser(int userid, java.util.Map<String, String> __ctx)
    {
        return begin_unregisterUser(userid, __ctx, true, null);
    }

    /**
     * Remove a user registration.
     * @param __cb The callback object for the operation.
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     **/
    public Ice.AsyncResult begin_unregisterUser(int userid, Ice.Callback __cb)
    {
        return begin_unregisterUser(userid, null, false, __cb);
    }

    /**
     * Remove a user registration.
     * @param __cb The callback object for the operation.
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_unregisterUser(int userid, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_unregisterUser(userid, __ctx, true, __cb);
    }

    /**
     * Remove a user registration.
     * @param __cb The callback object for the operation.
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     **/
    public Ice.AsyncResult begin_unregisterUser(int userid, Callback_Server_unregisterUser __cb)
    {
        return begin_unregisterUser(userid, null, false, __cb);
    }

    /**
     * Remove a user registration.
     * @param __cb The callback object for the operation.
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_unregisterUser(int userid, java.util.Map<String, String> __ctx, Callback_Server_unregisterUser __cb)
    {
        return begin_unregisterUser(userid, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_unregisterUser(int userid, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__unregisterUser_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __unregisterUser_name, __cb);
        try
        {
            __result.__prepare(__unregisterUser_name, Ice.OperationMode.Normal, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.writeInt(userid);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     **/
    public void end_unregisterUser(Ice.AsyncResult __result)
        throws InvalidSecretException,
               InvalidUserException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __unregisterUser_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(InvalidUserException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        IceInternal.BasicStream __is = __result.__is();
        __is.skipEmptyEncaps();
    }

    /**
     * Update the registration for a user. You can use this to set the email or password of a user,
     * and can also use it to change the user's name.
     * @param registration Updated registration record.
     **/
    public void
    updateRegistration(int userid, java.util.Map<UserInfo, java.lang.String> info)
        throws InvalidSecretException,
               InvalidUserException,
               ServerBootedException
    {
        updateRegistration(userid, info, null, false);
    }

    /**
     * Update the registration for a user. You can use this to set the email or password of a user,
     * and can also use it to change the user's name.
     * @param registration Updated registration record.
     * @param __ctx The Context map to send with the invocation.
     **/
    public void
    updateRegistration(int userid, java.util.Map<UserInfo, java.lang.String> info, java.util.Map<String, String> __ctx)
        throws InvalidSecretException,
               InvalidUserException,
               ServerBootedException
    {
        updateRegistration(userid, info, __ctx, true);
    }

    private void
    updateRegistration(int userid, java.util.Map<UserInfo, java.lang.String> info, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException,
               InvalidUserException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("updateRegistration");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                __del.updateRegistration(userid, info, __ctx);
                return;
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __updateRegistration_name = "updateRegistration";

    /**
     * Update the registration for a user. You can use this to set the email or password of a user,
     * and can also use it to change the user's name.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_updateRegistration(int userid, java.util.Map<UserInfo, java.lang.String> info)
    {
        return begin_updateRegistration(userid, info, null, false, null);
    }

    /**
     * Update the registration for a user. You can use this to set the email or password of a user,
     * and can also use it to change the user's name.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_updateRegistration(int userid, java.util.Map<UserInfo, java.lang.String> info, java.util.Map<String, String> __ctx)
    {
        return begin_updateRegistration(userid, info, __ctx, true, null);
    }

    /**
     * Update the registration for a user. You can use this to set the email or password of a user,
     * and can also use it to change the user's name.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_updateRegistration(int userid, java.util.Map<UserInfo, java.lang.String> info, Ice.Callback __cb)
    {
        return begin_updateRegistration(userid, info, null, false, __cb);
    }

    /**
     * Update the registration for a user. You can use this to set the email or password of a user,
     * and can also use it to change the user's name.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_updateRegistration(int userid, java.util.Map<UserInfo, java.lang.String> info, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_updateRegistration(userid, info, __ctx, true, __cb);
    }

    /**
     * Update the registration for a user. You can use this to set the email or password of a user,
     * and can also use it to change the user's name.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_updateRegistration(int userid, java.util.Map<UserInfo, java.lang.String> info, Callback_Server_updateRegistration __cb)
    {
        return begin_updateRegistration(userid, info, null, false, __cb);
    }

    /**
     * Update the registration for a user. You can use this to set the email or password of a user,
     * and can also use it to change the user's name.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_updateRegistration(int userid, java.util.Map<UserInfo, java.lang.String> info, java.util.Map<String, String> __ctx, Callback_Server_updateRegistration __cb)
    {
        return begin_updateRegistration(userid, info, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_updateRegistration(int userid, java.util.Map<UserInfo, java.lang.String> info, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__updateRegistration_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __updateRegistration_name, __cb);
        try
        {
            __result.__prepare(__updateRegistration_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.writeInt(userid);
            UserInfoMapHelper.write(__os, info);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     **/
    public void end_updateRegistration(Ice.AsyncResult __result)
        throws InvalidSecretException,
               InvalidUserException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __updateRegistration_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(InvalidUserException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        IceInternal.BasicStream __is = __result.__is();
        __is.skipEmptyEncaps();
    }

    /**
     * Verify the password of a user. You can use this to verify a user's credentials.
     * @param name User name. See {@link RegisteredUser.name}.
     * @param pw User password.
     * @return User ID of registered user (See {@link RegisteredUser.userid}), -1 for failed authentication or -2 for unknown usernames.
     **/
    public int
    verifyPassword(String name, String pw)
        throws InvalidSecretException,
               ServerBootedException
    {
        return verifyPassword(name, pw, null, false);
    }

    /**
     * Verify the password of a user. You can use this to verify a user's credentials.
     * @param name User name. See {@link RegisteredUser.name}.
     * @param pw User password.
     * @param __ctx The Context map to send with the invocation.
     * @return User ID of registered user (See {@link RegisteredUser.userid}), -1 for failed authentication or -2 for unknown usernames.
     **/
    public int
    verifyPassword(String name, String pw, java.util.Map<String, String> __ctx)
        throws InvalidSecretException,
               ServerBootedException
    {
        return verifyPassword(name, pw, __ctx, true);
    }

    private int
    verifyPassword(String name, String pw, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException,
               ServerBootedException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("verifyPassword");
                __delBase = __getDelegate(false);
                _ServerDel __del = (_ServerDel)__delBase;
                return __del.verifyPassword(name, pw, __ctx);
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __verifyPassword_name = "verifyPassword";

    /**
     * Verify the password of a user. You can use this to verify a user's credentials.
     * @param __cb The callback object for the operation.
     * @param name User name. See {@link RegisteredUser.name}.
     **/
    public Ice.AsyncResult begin_verifyPassword(String name, String pw)
    {
        return begin_verifyPassword(name, pw, null, false, null);
    }

    /**
     * Verify the password of a user. You can use this to verify a user's credentials.
     * @param __cb The callback object for the operation.
     * @param name User name. See {@link RegisteredUser.name}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_verifyPassword(String name, String pw, java.util.Map<String, String> __ctx)
    {
        return begin_verifyPassword(name, pw, __ctx, true, null);
    }

    /**
     * Verify the password of a user. You can use this to verify a user's credentials.
     * @param __cb The callback object for the operation.
     * @param name User name. See {@link RegisteredUser.name}.
     **/
    public Ice.AsyncResult begin_verifyPassword(String name, String pw, Ice.Callback __cb)
    {
        return begin_verifyPassword(name, pw, null, false, __cb);
    }

    /**
     * Verify the password of a user. You can use this to verify a user's credentials.
     * @param __cb The callback object for the operation.
     * @param name User name. See {@link RegisteredUser.name}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_verifyPassword(String name, String pw, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_verifyPassword(name, pw, __ctx, true, __cb);
    }

    /**
     * Verify the password of a user. You can use this to verify a user's credentials.
     * @param __cb The callback object for the operation.
     * @param name User name. See {@link RegisteredUser.name}.
     **/
    public Ice.AsyncResult begin_verifyPassword(String name, String pw, Callback_Server_verifyPassword __cb)
    {
        return begin_verifyPassword(name, pw, null, false, __cb);
    }

    /**
     * Verify the password of a user. You can use this to verify a user's credentials.
     * @param __cb The callback object for the operation.
     * @param name User name. See {@link RegisteredUser.name}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_verifyPassword(String name, String pw, java.util.Map<String, String> __ctx, Callback_Server_verifyPassword __cb)
    {
        return begin_verifyPassword(name, pw, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_verifyPassword(String name, String pw, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__verifyPassword_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __verifyPassword_name, __cb);
        try
        {
            __result.__prepare(__verifyPassword_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.writeString(name);
            __os.writeString(pw);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param __ret (return value) User ID of registered user (See {@link RegisteredUser.userid}), -1 for failed authentication or -2 for unknown usernames.
     **/
    public int end_verifyPassword(Ice.AsyncResult __result)
        throws InvalidSecretException,
               ServerBootedException
    {
        Ice.AsyncResult.__check(__result, this, __verifyPassword_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(ServerBootedException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        int __ret;
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        __ret = __is.readInt();
        __is.endReadEncaps();
        return __ret;
    }

    public static ServerPrx
    checkedCast(Ice.ObjectPrx __obj)
    {
        ServerPrx __d = null;
        if(__obj != null)
        {
            try
            {
                __d = (ServerPrx)__obj;
            }
            catch(ClassCastException ex)
            {
                if(__obj.ice_isA(ice_staticId()))
                {
                    ServerPrxHelper __h = new ServerPrxHelper();
                    __h.__copyFrom(__obj);
                    __d = __h;
                }
            }
        }
        return __d;
    }

    public static ServerPrx
    checkedCast(Ice.ObjectPrx __obj, java.util.Map<String, String> __ctx)
    {
        ServerPrx __d = null;
        if(__obj != null)
        {
            try
            {
                __d = (ServerPrx)__obj;
            }
            catch(ClassCastException ex)
            {
                if(__obj.ice_isA(ice_staticId(), __ctx))
                {
                    ServerPrxHelper __h = new ServerPrxHelper();
                    __h.__copyFrom(__obj);
                    __d = __h;
                }
            }
        }
        return __d;
    }

    public static ServerPrx
    checkedCast(Ice.ObjectPrx __obj, String __facet)
    {
        ServerPrx __d = null;
        if(__obj != null)
        {
            Ice.ObjectPrx __bb = __obj.ice_facet(__facet);
            try
            {
                if(__bb.ice_isA(ice_staticId()))
                {
                    ServerPrxHelper __h = new ServerPrxHelper();
                    __h.__copyFrom(__bb);
                    __d = __h;
                }
            }
            catch(Ice.FacetNotExistException ex)
            {
            }
        }
        return __d;
    }

    public static ServerPrx
    checkedCast(Ice.ObjectPrx __obj, String __facet, java.util.Map<String, String> __ctx)
    {
        ServerPrx __d = null;
        if(__obj != null)
        {
            Ice.ObjectPrx __bb = __obj.ice_facet(__facet);
            try
            {
                if(__bb.ice_isA(ice_staticId(), __ctx))
                {
                    ServerPrxHelper __h = new ServerPrxHelper();
                    __h.__copyFrom(__bb);
                    __d = __h;
                }
            }
            catch(Ice.FacetNotExistException ex)
            {
            }
        }
        return __d;
    }

    public static ServerPrx
    uncheckedCast(Ice.ObjectPrx __obj)
    {
        ServerPrx __d = null;
        if(__obj != null)
        {
            try
            {
                __d = (ServerPrx)__obj;
            }
            catch(ClassCastException ex)
            {
                ServerPrxHelper __h = new ServerPrxHelper();
                __h.__copyFrom(__obj);
                __d = __h;
            }
        }
        return __d;
    }

    public static ServerPrx
    uncheckedCast(Ice.ObjectPrx __obj, String __facet)
    {
        ServerPrx __d = null;
        if(__obj != null)
        {
            Ice.ObjectPrx __bb = __obj.ice_facet(__facet);
            ServerPrxHelper __h = new ServerPrxHelper();
            __h.__copyFrom(__bb);
            __d = __h;
        }
        return __d;
    }

    public static final String[] __ids =
    {
        "::Ice::Object",
        "::Murmur::Server"
    };

    public static String
    ice_staticId()
    {
        return __ids[1];
    }

    protected Ice._ObjectDelM
    __createDelegateM()
    {
        return new _ServerDelM();
    }

    protected Ice._ObjectDelD
    __createDelegateD()
    {
        return new _ServerDelD();
    }

    public static void
    __write(IceInternal.BasicStream __os, ServerPrx v)
    {
        __os.writeProxy(v);
    }

    public static ServerPrx
    __read(IceInternal.BasicStream __is)
    {
        Ice.ObjectPrx proxy = __is.readProxy();
        if(proxy != null)
        {
            ServerPrxHelper result = new ServerPrxHelper();
            result.__copyFrom(proxy);
            return result;
        }
        return null;
    }
}
