// **********************************************************************
//
// Copyright (c) 2003-2011 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.4.2
//
// <auto-generated>
//
// Generated from file `MetaPrxHelper.java'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

package Murmur;

/**
 * This is the meta interface. It is primarily used for retrieving the {@link Server} interfaces for each individual server.
 **/
public final class MetaPrxHelper extends Ice.ObjectPrxHelperBase implements MetaPrx
{
    /**
     * Add a callback. The callback will receive notifications when servers are started or stopped.
     * 
     * @param cb Callback interface which will receive notifications.
     **/
    public void
    addCallback(MetaCallbackPrx cb)
        throws InvalidCallbackException,
               InvalidSecretException
    {
        addCallback(cb, null, false);
    }

    /**
     * Add a callback. The callback will receive notifications when servers are started or stopped.
     * 
     * @param cb Callback interface which will receive notifications.
     * @param __ctx The Context map to send with the invocation.
     **/
    public void
    addCallback(MetaCallbackPrx cb, java.util.Map<String, String> __ctx)
        throws InvalidCallbackException,
               InvalidSecretException
    {
        addCallback(cb, __ctx, true);
    }

    private void
    addCallback(MetaCallbackPrx cb, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidCallbackException,
               InvalidSecretException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("addCallback");
                __delBase = __getDelegate(false);
                _MetaDel __del = (_MetaDel)__delBase;
                __del.addCallback(cb, __ctx);
                return;
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __handleExceptionWrapper(__delBase, __ex);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __addCallback_name = "addCallback";

    /**
     * Add a callback. The callback will receive notifications when servers are started or stopped.
     * 
     * @param __cb The callback object for the operation.
     * @param cb Callback interface which will receive notifications.
     **/
    public Ice.AsyncResult begin_addCallback(MetaCallbackPrx cb)
    {
        return begin_addCallback(cb, null, false, null);
    }

    /**
     * Add a callback. The callback will receive notifications when servers are started or stopped.
     * 
     * @param __cb The callback object for the operation.
     * @param cb Callback interface which will receive notifications.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_addCallback(MetaCallbackPrx cb, java.util.Map<String, String> __ctx)
    {
        return begin_addCallback(cb, __ctx, true, null);
    }

    /**
     * Add a callback. The callback will receive notifications when servers are started or stopped.
     * 
     * @param __cb The callback object for the operation.
     * @param cb Callback interface which will receive notifications.
     **/
    public Ice.AsyncResult begin_addCallback(MetaCallbackPrx cb, Ice.Callback __cb)
    {
        return begin_addCallback(cb, null, false, __cb);
    }

    /**
     * Add a callback. The callback will receive notifications when servers are started or stopped.
     * 
     * @param __cb The callback object for the operation.
     * @param cb Callback interface which will receive notifications.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_addCallback(MetaCallbackPrx cb, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_addCallback(cb, __ctx, true, __cb);
    }

    /**
     * Add a callback. The callback will receive notifications when servers are started or stopped.
     * 
     * @param __cb The callback object for the operation.
     * @param cb Callback interface which will receive notifications.
     **/
    public Ice.AsyncResult begin_addCallback(MetaCallbackPrx cb, Callback_Meta_addCallback __cb)
    {
        return begin_addCallback(cb, null, false, __cb);
    }

    /**
     * Add a callback. The callback will receive notifications when servers are started or stopped.
     * 
     * @param __cb The callback object for the operation.
     * @param cb Callback interface which will receive notifications.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_addCallback(MetaCallbackPrx cb, java.util.Map<String, String> __ctx, Callback_Meta_addCallback __cb)
    {
        return begin_addCallback(cb, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_addCallback(MetaCallbackPrx cb, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__addCallback_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __addCallback_name, __cb);
        try
        {
            __result.__prepare(__addCallback_name, Ice.OperationMode.Normal, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            MetaCallbackPrxHelper.__write(__os, cb);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     **/
    public void end_addCallback(Ice.AsyncResult __result)
        throws InvalidCallbackException,
               InvalidSecretException
    {
        Ice.AsyncResult.__check(__result, this, __addCallback_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidCallbackException __ex)
            {
                throw __ex;
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        IceInternal.BasicStream __is = __result.__is();
        __is.skipEmptyEncaps();
    }

    /**
     * Fetch list of all defined servers.
     * @return List of interfaces for all servers.
     **/
    public ServerPrx[]
    getAllServers()
        throws InvalidSecretException
    {
        return getAllServers(null, false);
    }

    /**
     * Fetch list of all defined servers.
     * @param __ctx The Context map to send with the invocation.
     * @return List of interfaces for all servers.
     **/
    public ServerPrx[]
    getAllServers(java.util.Map<String, String> __ctx)
        throws InvalidSecretException
    {
        return getAllServers(__ctx, true);
    }

    private ServerPrx[]
    getAllServers(java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("getAllServers");
                __delBase = __getDelegate(false);
                _MetaDel __del = (_MetaDel)__delBase;
                return __del.getAllServers(__ctx);
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __getAllServers_name = "getAllServers";

    /**
     * Fetch list of all defined servers.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getAllServers()
    {
        return begin_getAllServers(null, false, null);
    }

    /**
     * Fetch list of all defined servers.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getAllServers(java.util.Map<String, String> __ctx)
    {
        return begin_getAllServers(__ctx, true, null);
    }

    /**
     * Fetch list of all defined servers.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getAllServers(Ice.Callback __cb)
    {
        return begin_getAllServers(null, false, __cb);
    }

    /**
     * Fetch list of all defined servers.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getAllServers(java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_getAllServers(__ctx, true, __cb);
    }

    /**
     * Fetch list of all defined servers.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getAllServers(Callback_Meta_getAllServers __cb)
    {
        return begin_getAllServers(null, false, __cb);
    }

    /**
     * Fetch list of all defined servers.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getAllServers(java.util.Map<String, String> __ctx, Callback_Meta_getAllServers __cb)
    {
        return begin_getAllServers(__ctx, true, __cb);
    }

    private Ice.AsyncResult begin_getAllServers(java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__getAllServers_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __getAllServers_name, __cb);
        try
        {
            __result.__prepare(__getAllServers_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param __ret (return value) List of interfaces for all servers.
     **/
    public ServerPrx[] end_getAllServers(Ice.AsyncResult __result)
        throws InvalidSecretException
    {
        Ice.AsyncResult.__check(__result, this, __getAllServers_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        ServerPrx[] __ret;
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        __ret = ServerListHelper.read(__is);
        __is.endReadEncaps();
        return __ret;
    }

    /**
     * Fetch list of all currently running servers.
     * @return List of interfaces for running servers.
     **/
    public ServerPrx[]
    getBootedServers()
        throws InvalidSecretException
    {
        return getBootedServers(null, false);
    }

    /**
     * Fetch list of all currently running servers.
     * @param __ctx The Context map to send with the invocation.
     * @return List of interfaces for running servers.
     **/
    public ServerPrx[]
    getBootedServers(java.util.Map<String, String> __ctx)
        throws InvalidSecretException
    {
        return getBootedServers(__ctx, true);
    }

    private ServerPrx[]
    getBootedServers(java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("getBootedServers");
                __delBase = __getDelegate(false);
                _MetaDel __del = (_MetaDel)__delBase;
                return __del.getBootedServers(__ctx);
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __getBootedServers_name = "getBootedServers";

    /**
     * Fetch list of all currently running servers.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getBootedServers()
    {
        return begin_getBootedServers(null, false, null);
    }

    /**
     * Fetch list of all currently running servers.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getBootedServers(java.util.Map<String, String> __ctx)
    {
        return begin_getBootedServers(__ctx, true, null);
    }

    /**
     * Fetch list of all currently running servers.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getBootedServers(Ice.Callback __cb)
    {
        return begin_getBootedServers(null, false, __cb);
    }

    /**
     * Fetch list of all currently running servers.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getBootedServers(java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_getBootedServers(__ctx, true, __cb);
    }

    /**
     * Fetch list of all currently running servers.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getBootedServers(Callback_Meta_getBootedServers __cb)
    {
        return begin_getBootedServers(null, false, __cb);
    }

    /**
     * Fetch list of all currently running servers.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getBootedServers(java.util.Map<String, String> __ctx, Callback_Meta_getBootedServers __cb)
    {
        return begin_getBootedServers(__ctx, true, __cb);
    }

    private Ice.AsyncResult begin_getBootedServers(java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__getBootedServers_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __getBootedServers_name, __cb);
        try
        {
            __result.__prepare(__getBootedServers_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param __ret (return value) List of interfaces for running servers.
     **/
    public ServerPrx[] end_getBootedServers(Ice.AsyncResult __result)
        throws InvalidSecretException
    {
        Ice.AsyncResult.__check(__result, this, __getBootedServers_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        ServerPrx[] __ret;
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        __ret = ServerListHelper.read(__is);
        __is.endReadEncaps();
        return __ret;
    }

    /**
     * Fetch default configuraion. This returns the configuration items that were set in the configuration file, or
     * the built-in default. The individual servers will use these values unless they have been overridden in the
     * server specific configuration. The only special case is the port, which defaults to the value defined here +
     * the servers ID - 1 (so that virtual server #1 uses the defined port, server #2 uses port+1 etc).
     * @return Default configuration of the servers.
     **/
    public java.util.Map<java.lang.String, java.lang.String>
    getDefaultConf()
        throws InvalidSecretException
    {
        return getDefaultConf(null, false);
    }

    /**
     * Fetch default configuraion. This returns the configuration items that were set in the configuration file, or
     * the built-in default. The individual servers will use these values unless they have been overridden in the
     * server specific configuration. The only special case is the port, which defaults to the value defined here +
     * the servers ID - 1 (so that virtual server #1 uses the defined port, server #2 uses port+1 etc).
     * @param __ctx The Context map to send with the invocation.
     * @return Default configuration of the servers.
     **/
    public java.util.Map<java.lang.String, java.lang.String>
    getDefaultConf(java.util.Map<String, String> __ctx)
        throws InvalidSecretException
    {
        return getDefaultConf(__ctx, true);
    }

    private java.util.Map<java.lang.String, java.lang.String>
    getDefaultConf(java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("getDefaultConf");
                __delBase = __getDelegate(false);
                _MetaDel __del = (_MetaDel)__delBase;
                return __del.getDefaultConf(__ctx);
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __getDefaultConf_name = "getDefaultConf";

    /**
     * Fetch default configuraion. This returns the configuration items that were set in the configuration file, or
     * the built-in default. The individual servers will use these values unless they have been overridden in the
     * server specific configuration. The only special case is the port, which defaults to the value defined here +
     * the servers ID - 1 (so that virtual server #1 uses the defined port, server #2 uses port+1 etc).
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getDefaultConf()
    {
        return begin_getDefaultConf(null, false, null);
    }

    /**
     * Fetch default configuraion. This returns the configuration items that were set in the configuration file, or
     * the built-in default. The individual servers will use these values unless they have been overridden in the
     * server specific configuration. The only special case is the port, which defaults to the value defined here +
     * the servers ID - 1 (so that virtual server #1 uses the defined port, server #2 uses port+1 etc).
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getDefaultConf(java.util.Map<String, String> __ctx)
    {
        return begin_getDefaultConf(__ctx, true, null);
    }

    /**
     * Fetch default configuraion. This returns the configuration items that were set in the configuration file, or
     * the built-in default. The individual servers will use these values unless they have been overridden in the
     * server specific configuration. The only special case is the port, which defaults to the value defined here +
     * the servers ID - 1 (so that virtual server #1 uses the defined port, server #2 uses port+1 etc).
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getDefaultConf(Ice.Callback __cb)
    {
        return begin_getDefaultConf(null, false, __cb);
    }

    /**
     * Fetch default configuraion. This returns the configuration items that were set in the configuration file, or
     * the built-in default. The individual servers will use these values unless they have been overridden in the
     * server specific configuration. The only special case is the port, which defaults to the value defined here +
     * the servers ID - 1 (so that virtual server #1 uses the defined port, server #2 uses port+1 etc).
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getDefaultConf(java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_getDefaultConf(__ctx, true, __cb);
    }

    /**
     * Fetch default configuraion. This returns the configuration items that were set in the configuration file, or
     * the built-in default. The individual servers will use these values unless they have been overridden in the
     * server specific configuration. The only special case is the port, which defaults to the value defined here +
     * the servers ID - 1 (so that virtual server #1 uses the defined port, server #2 uses port+1 etc).
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getDefaultConf(Callback_Meta_getDefaultConf __cb)
    {
        return begin_getDefaultConf(null, false, __cb);
    }

    /**
     * Fetch default configuraion. This returns the configuration items that were set in the configuration file, or
     * the built-in default. The individual servers will use these values unless they have been overridden in the
     * server specific configuration. The only special case is the port, which defaults to the value defined here +
     * the servers ID - 1 (so that virtual server #1 uses the defined port, server #2 uses port+1 etc).
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getDefaultConf(java.util.Map<String, String> __ctx, Callback_Meta_getDefaultConf __cb)
    {
        return begin_getDefaultConf(__ctx, true, __cb);
    }

    private Ice.AsyncResult begin_getDefaultConf(java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__getDefaultConf_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __getDefaultConf_name, __cb);
        try
        {
            __result.__prepare(__getDefaultConf_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param __ret (return value) Default configuration of the servers.
     **/
    public java.util.Map<java.lang.String, java.lang.String> end_getDefaultConf(Ice.AsyncResult __result)
        throws InvalidSecretException
    {
        Ice.AsyncResult.__check(__result, this, __getDefaultConf_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        java.util.Map<java.lang.String, java.lang.String> __ret;
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        __ret = ConfigMapHelper.read(__is);
        __is.endReadEncaps();
        return __ret;
    }

    /**
     * Fetch interface to specific server.
     * @param id Server ID. See {@link Server.getId}.
     * @return Interface for specified server, or a null proxy if id is invalid.
     **/
    public ServerPrx
    getServer(int id)
        throws InvalidSecretException
    {
        return getServer(id, null, false);
    }

    /**
     * Fetch interface to specific server.
     * @param id Server ID. See {@link Server.getId}.
     * @param __ctx The Context map to send with the invocation.
     * @return Interface for specified server, or a null proxy if id is invalid.
     **/
    public ServerPrx
    getServer(int id, java.util.Map<String, String> __ctx)
        throws InvalidSecretException
    {
        return getServer(id, __ctx, true);
    }

    private ServerPrx
    getServer(int id, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("getServer");
                __delBase = __getDelegate(false);
                _MetaDel __del = (_MetaDel)__delBase;
                return __del.getServer(id, __ctx);
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __getServer_name = "getServer";

    /**
     * Fetch interface to specific server.
     * @param __cb The callback object for the operation.
     * @param id Server ID. See {@link Server.getId}.
     **/
    public Ice.AsyncResult begin_getServer(int id)
    {
        return begin_getServer(id, null, false, null);
    }

    /**
     * Fetch interface to specific server.
     * @param __cb The callback object for the operation.
     * @param id Server ID. See {@link Server.getId}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getServer(int id, java.util.Map<String, String> __ctx)
    {
        return begin_getServer(id, __ctx, true, null);
    }

    /**
     * Fetch interface to specific server.
     * @param __cb The callback object for the operation.
     * @param id Server ID. See {@link Server.getId}.
     **/
    public Ice.AsyncResult begin_getServer(int id, Ice.Callback __cb)
    {
        return begin_getServer(id, null, false, __cb);
    }

    /**
     * Fetch interface to specific server.
     * @param __cb The callback object for the operation.
     * @param id Server ID. See {@link Server.getId}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getServer(int id, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_getServer(id, __ctx, true, __cb);
    }

    /**
     * Fetch interface to specific server.
     * @param __cb The callback object for the operation.
     * @param id Server ID. See {@link Server.getId}.
     **/
    public Ice.AsyncResult begin_getServer(int id, Callback_Meta_getServer __cb)
    {
        return begin_getServer(id, null, false, __cb);
    }

    /**
     * Fetch interface to specific server.
     * @param __cb The callback object for the operation.
     * @param id Server ID. See {@link Server.getId}.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getServer(int id, java.util.Map<String, String> __ctx, Callback_Meta_getServer __cb)
    {
        return begin_getServer(id, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_getServer(int id, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__getServer_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __getServer_name, __cb);
        try
        {
            __result.__prepare(__getServer_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.writeInt(id);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param __ret (return value) Interface for specified server, or a null proxy if id is invalid.
     **/
    public ServerPrx end_getServer(Ice.AsyncResult __result)
        throws InvalidSecretException
    {
        Ice.AsyncResult.__check(__result, this, __getServer_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        ServerPrx __ret;
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        __ret = ServerPrxHelper.__read(__is);
        __is.endReadEncaps();
        return __ret;
    }

    /**
     * Get slice file.
     * @return Contents of the slice file server compiled with.
     **/
    public String
    getSlice()
    {
        return getSlice(null, false);
    }

    /**
     * Get slice file.
     * @param __ctx The Context map to send with the invocation.
     * @return Contents of the slice file server compiled with.
     **/
    public String
    getSlice(java.util.Map<String, String> __ctx)
    {
        return getSlice(__ctx, true);
    }

    private String
    getSlice(java.util.Map<String, String> __ctx, boolean __explicitCtx)
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("getSlice");
                __delBase = __getDelegate(false);
                _MetaDel __del = (_MetaDel)__delBase;
                return __del.getSlice(__ctx);
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __getSlice_name = "getSlice";

    /**
     * Get slice file.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getSlice()
    {
        return begin_getSlice(null, false, null);
    }

    /**
     * Get slice file.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getSlice(java.util.Map<String, String> __ctx)
    {
        return begin_getSlice(__ctx, true, null);
    }

    /**
     * Get slice file.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getSlice(Ice.Callback __cb)
    {
        return begin_getSlice(null, false, __cb);
    }

    /**
     * Get slice file.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getSlice(java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_getSlice(__ctx, true, __cb);
    }

    /**
     * Get slice file.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getSlice(Callback_Meta_getSlice __cb)
    {
        return begin_getSlice(null, false, __cb);
    }

    /**
     * Get slice file.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getSlice(java.util.Map<String, String> __ctx, Callback_Meta_getSlice __cb)
    {
        return begin_getSlice(__ctx, true, __cb);
    }

    private Ice.AsyncResult begin_getSlice(java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__getSlice_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __getSlice_name, __cb);
        try
        {
            __result.__prepare(__getSlice_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param __ret (return value) Contents of the slice file server compiled with.
     **/
    public String end_getSlice(Ice.AsyncResult __result)
    {
        Ice.AsyncResult.__check(__result, this, __getSlice_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        String __ret;
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        __ret = __is.readString();
        __is.endReadEncaps();
        return __ret;
    }

    /**
     * Returns a checksum dict for the slice file.
     * @return Checksum dict
     **/
    public java.util.Map<java.lang.String, java.lang.String>
    getSliceChecksums()
    {
        return getSliceChecksums(null, false);
    }

    /**
     * Returns a checksum dict for the slice file.
     * @param __ctx The Context map to send with the invocation.
     * @return Checksum dict
     **/
    public java.util.Map<java.lang.String, java.lang.String>
    getSliceChecksums(java.util.Map<String, String> __ctx)
    {
        return getSliceChecksums(__ctx, true);
    }

    private java.util.Map<java.lang.String, java.lang.String>
    getSliceChecksums(java.util.Map<String, String> __ctx, boolean __explicitCtx)
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("getSliceChecksums");
                __delBase = __getDelegate(false);
                _MetaDel __del = (_MetaDel)__delBase;
                return __del.getSliceChecksums(__ctx);
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __getSliceChecksums_name = "getSliceChecksums";

    /**
     * Returns a checksum dict for the slice file.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getSliceChecksums()
    {
        return begin_getSliceChecksums(null, false, null);
    }

    /**
     * Returns a checksum dict for the slice file.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getSliceChecksums(java.util.Map<String, String> __ctx)
    {
        return begin_getSliceChecksums(__ctx, true, null);
    }

    /**
     * Returns a checksum dict for the slice file.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getSliceChecksums(Ice.Callback __cb)
    {
        return begin_getSliceChecksums(null, false, __cb);
    }

    /**
     * Returns a checksum dict for the slice file.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getSliceChecksums(java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_getSliceChecksums(__ctx, true, __cb);
    }

    /**
     * Returns a checksum dict for the slice file.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getSliceChecksums(Callback_Meta_getSliceChecksums __cb)
    {
        return begin_getSliceChecksums(null, false, __cb);
    }

    /**
     * Returns a checksum dict for the slice file.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getSliceChecksums(java.util.Map<String, String> __ctx, Callback_Meta_getSliceChecksums __cb)
    {
        return begin_getSliceChecksums(__ctx, true, __cb);
    }

    private Ice.AsyncResult begin_getSliceChecksums(java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__getSliceChecksums_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __getSliceChecksums_name, __cb);
        try
        {
            __result.__prepare(__getSliceChecksums_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param __ret (return value) Checksum dict
     **/
    public java.util.Map<java.lang.String, java.lang.String> end_getSliceChecksums(Ice.AsyncResult __result)
    {
        Ice.AsyncResult.__check(__result, this, __getSliceChecksums_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        java.util.Map<java.lang.String, java.lang.String> __ret;
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        __ret = Ice.SliceChecksumDictHelper.read(__is);
        __is.endReadEncaps();
        return __ret;
    }

    /**
     * Get murmur uptime.
     * @return Uptime of murmur in seconds
     **/
    public int
    getUptime()
    {
        return getUptime(null, false);
    }

    /**
     * Get murmur uptime.
     * @param __ctx The Context map to send with the invocation.
     * @return Uptime of murmur in seconds
     **/
    public int
    getUptime(java.util.Map<String, String> __ctx)
    {
        return getUptime(__ctx, true);
    }

    private int
    getUptime(java.util.Map<String, String> __ctx, boolean __explicitCtx)
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("getUptime");
                __delBase = __getDelegate(false);
                _MetaDel __del = (_MetaDel)__delBase;
                return __del.getUptime(__ctx);
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __getUptime_name = "getUptime";

    /**
     * Get murmur uptime.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getUptime()
    {
        return begin_getUptime(null, false, null);
    }

    /**
     * Get murmur uptime.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getUptime(java.util.Map<String, String> __ctx)
    {
        return begin_getUptime(__ctx, true, null);
    }

    /**
     * Get murmur uptime.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getUptime(Ice.Callback __cb)
    {
        return begin_getUptime(null, false, __cb);
    }

    /**
     * Get murmur uptime.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getUptime(java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_getUptime(__ctx, true, __cb);
    }

    /**
     * Get murmur uptime.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getUptime(Callback_Meta_getUptime __cb)
    {
        return begin_getUptime(null, false, __cb);
    }

    /**
     * Get murmur uptime.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getUptime(java.util.Map<String, String> __ctx, Callback_Meta_getUptime __cb)
    {
        return begin_getUptime(__ctx, true, __cb);
    }

    private Ice.AsyncResult begin_getUptime(java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__getUptime_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __getUptime_name, __cb);
        try
        {
            __result.__prepare(__getUptime_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param __ret (return value) Uptime of murmur in seconds
     **/
    public int end_getUptime(Ice.AsyncResult __result)
    {
        Ice.AsyncResult.__check(__result, this, __getUptime_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        int __ret;
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        __ret = __is.readInt();
        __is.endReadEncaps();
        return __ret;
    }

    /**
     * Fetch version of Murmur. 
     * @param major Major version.
     * @param minor Minor version.
     * @param patch Patchlevel.
     * @param text Textual representation of version. Note that this may not match the {@link major}, {@link minor} and {@link patch} levels, as it
     * may be simply the compile date or the SVN revision. This is usually the text you want to present to users.
     **/
    public void
    getVersion(Ice.IntHolder major, Ice.IntHolder minor, Ice.IntHolder patch, Ice.StringHolder text)
    {
        getVersion(major, minor, patch, text, null, false);
    }

    /**
     * Fetch version of Murmur. 
     * @param major Major version.
     * @param minor Minor version.
     * @param patch Patchlevel.
     * @param text Textual representation of version. Note that this may not match the {@link major}, {@link minor} and {@link patch} levels, as it
     * may be simply the compile date or the SVN revision. This is usually the text you want to present to users.
     * @param __ctx The Context map to send with the invocation.
     **/
    public void
    getVersion(Ice.IntHolder major, Ice.IntHolder minor, Ice.IntHolder patch, Ice.StringHolder text, java.util.Map<String, String> __ctx)
    {
        getVersion(major, minor, patch, text, __ctx, true);
    }

    private void
    getVersion(Ice.IntHolder major, Ice.IntHolder minor, Ice.IntHolder patch, Ice.StringHolder text, java.util.Map<String, String> __ctx, boolean __explicitCtx)
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("getVersion");
                __delBase = __getDelegate(false);
                _MetaDel __del = (_MetaDel)__delBase;
                __del.getVersion(major, minor, patch, text, __ctx);
                return;
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __cnt = __handleExceptionWrapperRelaxed(__delBase, __ex, null, __cnt);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __getVersion_name = "getVersion";

    /**
     * Fetch version of Murmur. 
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getVersion()
    {
        return begin_getVersion(null, false, null);
    }

    /**
     * Fetch version of Murmur. 
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getVersion(java.util.Map<String, String> __ctx)
    {
        return begin_getVersion(__ctx, true, null);
    }

    /**
     * Fetch version of Murmur. 
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getVersion(Ice.Callback __cb)
    {
        return begin_getVersion(null, false, __cb);
    }

    /**
     * Fetch version of Murmur. 
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getVersion(java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_getVersion(__ctx, true, __cb);
    }

    /**
     * Fetch version of Murmur. 
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_getVersion(Callback_Meta_getVersion __cb)
    {
        return begin_getVersion(null, false, __cb);
    }

    /**
     * Fetch version of Murmur. 
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_getVersion(java.util.Map<String, String> __ctx, Callback_Meta_getVersion __cb)
    {
        return begin_getVersion(__ctx, true, __cb);
    }

    private Ice.AsyncResult begin_getVersion(java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__getVersion_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __getVersion_name, __cb);
        try
        {
            __result.__prepare(__getVersion_name, Ice.OperationMode.Idempotent, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param major Major version.
     * @param patch Patchlevel.
     **/
    public void end_getVersion(Ice.IntHolder major, Ice.IntHolder minor, Ice.IntHolder patch, Ice.StringHolder text, Ice.AsyncResult __result)
    {
        Ice.AsyncResult.__check(__result, this, __getVersion_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        major.value = __is.readInt();
        minor.value = __is.readInt();
        patch.value = __is.readInt();
        text.value = __is.readString();
        __is.endReadEncaps();
    }

    /**
     * Create a new server. Call {@link Server.getId} on the returned interface to find it's ID.
     * @return Interface for new server.
     **/
    public ServerPrx
    newServer()
        throws InvalidSecretException
    {
        return newServer(null, false);
    }

    /**
     * Create a new server. Call {@link Server.getId} on the returned interface to find it's ID.
     * @param __ctx The Context map to send with the invocation.
     * @return Interface for new server.
     **/
    public ServerPrx
    newServer(java.util.Map<String, String> __ctx)
        throws InvalidSecretException
    {
        return newServer(__ctx, true);
    }

    private ServerPrx
    newServer(java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidSecretException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("newServer");
                __delBase = __getDelegate(false);
                _MetaDel __del = (_MetaDel)__delBase;
                return __del.newServer(__ctx);
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __handleExceptionWrapper(__delBase, __ex);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __newServer_name = "newServer";

    /**
     * Create a new server. Call {@link Server.getId} on the returned interface to find it's ID.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_newServer()
    {
        return begin_newServer(null, false, null);
    }

    /**
     * Create a new server. Call {@link Server.getId} on the returned interface to find it's ID.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_newServer(java.util.Map<String, String> __ctx)
    {
        return begin_newServer(__ctx, true, null);
    }

    /**
     * Create a new server. Call {@link Server.getId} on the returned interface to find it's ID.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_newServer(Ice.Callback __cb)
    {
        return begin_newServer(null, false, __cb);
    }

    /**
     * Create a new server. Call {@link Server.getId} on the returned interface to find it's ID.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_newServer(java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_newServer(__ctx, true, __cb);
    }

    /**
     * Create a new server. Call {@link Server.getId} on the returned interface to find it's ID.
     * @param __cb The callback object for the operation.
     **/
    public Ice.AsyncResult begin_newServer(Callback_Meta_newServer __cb)
    {
        return begin_newServer(null, false, __cb);
    }

    /**
     * Create a new server. Call {@link Server.getId} on the returned interface to find it's ID.
     * @param __cb The callback object for the operation.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_newServer(java.util.Map<String, String> __ctx, Callback_Meta_newServer __cb)
    {
        return begin_newServer(__ctx, true, __cb);
    }

    private Ice.AsyncResult begin_newServer(java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__newServer_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __newServer_name, __cb);
        try
        {
            __result.__prepare(__newServer_name, Ice.OperationMode.Normal, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     * @param __ret (return value) Interface for new server.
     **/
    public ServerPrx end_newServer(Ice.AsyncResult __result)
        throws InvalidSecretException
    {
        Ice.AsyncResult.__check(__result, this, __newServer_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        ServerPrx __ret;
        IceInternal.BasicStream __is = __result.__is();
        __is.startReadEncaps();
        __ret = ServerPrxHelper.__read(__is);
        __is.endReadEncaps();
        return __ret;
    }

    /**
     * Remove a callback.
     * 
     * @param cb Callback interface to be removed.
     **/
    public void
    removeCallback(MetaCallbackPrx cb)
        throws InvalidCallbackException,
               InvalidSecretException
    {
        removeCallback(cb, null, false);
    }

    /**
     * Remove a callback.
     * 
     * @param cb Callback interface to be removed.
     * @param __ctx The Context map to send with the invocation.
     **/
    public void
    removeCallback(MetaCallbackPrx cb, java.util.Map<String, String> __ctx)
        throws InvalidCallbackException,
               InvalidSecretException
    {
        removeCallback(cb, __ctx, true);
    }

    private void
    removeCallback(MetaCallbackPrx cb, java.util.Map<String, String> __ctx, boolean __explicitCtx)
        throws InvalidCallbackException,
               InvalidSecretException
    {
        if(__explicitCtx && __ctx == null)
        {
            __ctx = _emptyContext;
        }
        int __cnt = 0;
        while(true)
        {
            Ice._ObjectDel __delBase = null;
            try
            {
                __checkTwowayOnly("removeCallback");
                __delBase = __getDelegate(false);
                _MetaDel __del = (_MetaDel)__delBase;
                __del.removeCallback(cb, __ctx);
                return;
            }
            catch(IceInternal.LocalExceptionWrapper __ex)
            {
                __handleExceptionWrapper(__delBase, __ex);
            }
            catch(Ice.LocalException __ex)
            {
                __cnt = __handleException(__delBase, __ex, null, __cnt);
            }
        }
    }

    private static final String __removeCallback_name = "removeCallback";

    /**
     * Remove a callback.
     * 
     * @param __cb The callback object for the operation.
     * @param cb Callback interface to be removed.
     **/
    public Ice.AsyncResult begin_removeCallback(MetaCallbackPrx cb)
    {
        return begin_removeCallback(cb, null, false, null);
    }

    /**
     * Remove a callback.
     * 
     * @param __cb The callback object for the operation.
     * @param cb Callback interface to be removed.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_removeCallback(MetaCallbackPrx cb, java.util.Map<String, String> __ctx)
    {
        return begin_removeCallback(cb, __ctx, true, null);
    }

    /**
     * Remove a callback.
     * 
     * @param __cb The callback object for the operation.
     * @param cb Callback interface to be removed.
     **/
    public Ice.AsyncResult begin_removeCallback(MetaCallbackPrx cb, Ice.Callback __cb)
    {
        return begin_removeCallback(cb, null, false, __cb);
    }

    /**
     * Remove a callback.
     * 
     * @param __cb The callback object for the operation.
     * @param cb Callback interface to be removed.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_removeCallback(MetaCallbackPrx cb, java.util.Map<String, String> __ctx, Ice.Callback __cb)
    {
        return begin_removeCallback(cb, __ctx, true, __cb);
    }

    /**
     * Remove a callback.
     * 
     * @param __cb The callback object for the operation.
     * @param cb Callback interface to be removed.
     **/
    public Ice.AsyncResult begin_removeCallback(MetaCallbackPrx cb, Callback_Meta_removeCallback __cb)
    {
        return begin_removeCallback(cb, null, false, __cb);
    }

    /**
     * Remove a callback.
     * 
     * @param __cb The callback object for the operation.
     * @param cb Callback interface to be removed.
     * @param __ctx The Context map to send with the invocation.
     **/
    public Ice.AsyncResult begin_removeCallback(MetaCallbackPrx cb, java.util.Map<String, String> __ctx, Callback_Meta_removeCallback __cb)
    {
        return begin_removeCallback(cb, __ctx, true, __cb);
    }

    private Ice.AsyncResult begin_removeCallback(MetaCallbackPrx cb, java.util.Map<String, String> __ctx, boolean __explicitCtx, IceInternal.CallbackBase __cb)
    {
        __checkAsyncTwowayOnly(__removeCallback_name);
        IceInternal.OutgoingAsync __result = new IceInternal.OutgoingAsync(this, __removeCallback_name, __cb);
        try
        {
            __result.__prepare(__removeCallback_name, Ice.OperationMode.Normal, __ctx, __explicitCtx);
            IceInternal.BasicStream __os = __result.__os();
            MetaCallbackPrxHelper.__write(__os, cb);
            __os.endWriteEncaps();
            __result.__send(true);
        }
        catch(Ice.LocalException __ex)
        {
            __result.__exceptionAsync(__ex);
        }
        return __result;
    }

    /**
     * ice_response indicates that
     * the operation completed successfully.
     **/
    public void end_removeCallback(Ice.AsyncResult __result)
        throws InvalidCallbackException,
               InvalidSecretException
    {
        Ice.AsyncResult.__check(__result, this, __removeCallback_name);
        if(!__result.__wait())
        {
            try
            {
                __result.__throwUserException();
            }
            catch(InvalidCallbackException __ex)
            {
                throw __ex;
            }
            catch(InvalidSecretException __ex)
            {
                throw __ex;
            }
            catch(Ice.UserException __ex)
            {
                throw new Ice.UnknownUserException(__ex.ice_name(), __ex);
            }
        }
        IceInternal.BasicStream __is = __result.__is();
        __is.skipEmptyEncaps();
    }

    public static MetaPrx
    checkedCast(Ice.ObjectPrx __obj)
    {
        MetaPrx __d = null;
        if(__obj != null)
        {
            try
            {
                __d = (MetaPrx)__obj;
            }
            catch(ClassCastException ex)
            {
                if(__obj.ice_isA(ice_staticId()))
                {
                    MetaPrxHelper __h = new MetaPrxHelper();
                    __h.__copyFrom(__obj);
                    __d = __h;
                }
            }
        }
        return __d;
    }

    public static MetaPrx
    checkedCast(Ice.ObjectPrx __obj, java.util.Map<String, String> __ctx)
    {
        MetaPrx __d = null;
        if(__obj != null)
        {
            try
            {
                __d = (MetaPrx)__obj;
            }
            catch(ClassCastException ex)
            {
                if(__obj.ice_isA(ice_staticId(), __ctx))
                {
                    MetaPrxHelper __h = new MetaPrxHelper();
                    __h.__copyFrom(__obj);
                    __d = __h;
                }
            }
        }
        return __d;
    }

    public static MetaPrx
    checkedCast(Ice.ObjectPrx __obj, String __facet)
    {
        MetaPrx __d = null;
        if(__obj != null)
        {
            Ice.ObjectPrx __bb = __obj.ice_facet(__facet);
            try
            {
                if(__bb.ice_isA(ice_staticId()))
                {
                    MetaPrxHelper __h = new MetaPrxHelper();
                    __h.__copyFrom(__bb);
                    __d = __h;
                }
            }
            catch(Ice.FacetNotExistException ex)
            {
            }
        }
        return __d;
    }

    public static MetaPrx
    checkedCast(Ice.ObjectPrx __obj, String __facet, java.util.Map<String, String> __ctx)
    {
        MetaPrx __d = null;
        if(__obj != null)
        {
            Ice.ObjectPrx __bb = __obj.ice_facet(__facet);
            try
            {
                if(__bb.ice_isA(ice_staticId(), __ctx))
                {
                    MetaPrxHelper __h = new MetaPrxHelper();
                    __h.__copyFrom(__bb);
                    __d = __h;
                }
            }
            catch(Ice.FacetNotExistException ex)
            {
            }
        }
        return __d;
    }

    public static MetaPrx
    uncheckedCast(Ice.ObjectPrx __obj)
    {
        MetaPrx __d = null;
        if(__obj != null)
        {
            try
            {
                __d = (MetaPrx)__obj;
            }
            catch(ClassCastException ex)
            {
                MetaPrxHelper __h = new MetaPrxHelper();
                __h.__copyFrom(__obj);
                __d = __h;
            }
        }
        return __d;
    }

    public static MetaPrx
    uncheckedCast(Ice.ObjectPrx __obj, String __facet)
    {
        MetaPrx __d = null;
        if(__obj != null)
        {
            Ice.ObjectPrx __bb = __obj.ice_facet(__facet);
            MetaPrxHelper __h = new MetaPrxHelper();
            __h.__copyFrom(__bb);
            __d = __h;
        }
        return __d;
    }

    public static final String[] __ids =
    {
        "::Ice::Object",
        "::Murmur::Meta"
    };

    public static String
    ice_staticId()
    {
        return __ids[1];
    }

    protected Ice._ObjectDelM
    __createDelegateM()
    {
        return new _MetaDelM();
    }

    protected Ice._ObjectDelD
    __createDelegateD()
    {
        return new _MetaDelD();
    }

    public static void
    __write(IceInternal.BasicStream __os, MetaPrx v)
    {
        __os.writeProxy(v);
    }

    public static MetaPrx
    __read(IceInternal.BasicStream __is)
    {
        Ice.ObjectPrx proxy = __is.readProxy();
        if(proxy != null)
        {
            MetaPrxHelper result = new MetaPrxHelper();
            result.__copyFrom(proxy);
            return result;
        }
        return null;
    }
}
